<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eddie's Portfolio</title>
    <link rel="icon" type="image/x-icon" href="assets/images/favicon.ico">
    
    <!-- CSS -->
    <link rel="stylesheet" href="assets/css/reset.css">
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="stylesheet" href="assets/css/animations.css">

    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <!-- Add custom CSS for SplashCursor -->
    <style>
        #splash-cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- SplashCursor Container -->
    <div id="splash-cursor"></div>

    <header>
        <a href="#" class="logo"><img src="assets/images/favicon.ico" alt="favicon" class="nav-favicon">Eddie</a>
        <nav class="navbar">
            <a href="#research">My Research</a>
            <a href="#project">My Project</a>
            <a href="#life">My Life</a>
        </nav>
    </header>

    <section id="research" class="section">
        <div class="background"></div>
        <div class="content">
            <h2>过去 (Past)</h2>
            <h3>回忆如诗，经历如画<br>The memories like poetry, experiences like paintings</h3>
            
            <p class="chinese-text">我曾经的足迹，化作今日的养分</p>
            <p class="english-text">My past footprints transformed into today's nourishment</p>
            
            <p class="chinese-text">每一次跌倒，每一次尝试</p>
            <p class="english-text">Each fall, each attempt</p>
            
            <p class="chinese-text">都在灵魂上留下独特的纹理</p>
            <p class="english-text">Left unique textures on my soul</p>
        </div>
    </section>

    <section id="project" class="section">
        <div class="background"></div>
        <div class="content">
            <h2>现在 (Present)</h2>
            <h3>此刻如歌，当下如舞<br>This moment like a song, the present like a dance</h3>
            
            <p class="chinese-text">站在时间的交叉点</p>
            <p class="english-text">Standing at the crossroads of time</p>
            
            <p class="chinese-text">感受创作的脉搏与热情</p>
            <p class="english-text">Feeling the pulse and passion of creation</p>
            
            <p class="chinese-text">将所见所闻，化为艺术的表达</p>
            <p class="english-text">Transforming what I see and hear into artistic expression</p>
        </div>
    </section>

    <section id="life" class="section">
        <div class="background"></div>
        <div class="content">
            <h2>未来 (Future)</h2>
            <h3>梦想如星，愿景如海<br>Dreams like stars, vision like the sea</h3>
            
            <p class="chinese-text">在未知的画布上，描绘无限可能</p>
            <p class="english-text">On the unknown canvas, painting infinite possibilities</p>
            
            <p class="chinese-text">跨越边界，融合创新</p>
            <p class="english-text">Crossing boundaries, merging innovations</p>
            
            <p class="chinese-text">以艺术之名，探索未竟之路</p>
            <p class="english-text">In the name of art, exploring the unfinished path</p>
        </div>
    </section>

    <!-- Script to load and render the SplashCursor component -->
    <script type="text/babel">
        // Import the SplashCursor component
        const { useEffect, useRef } = React;

        // Include the SplashCursor component directly
        function SplashCursor({
          // Default parameters
          SIM_RESOLUTION = 128,
          DYE_RESOLUTION = 1440,
          CAPTURE_RESOLUTION = 512,
          DENSITY_DISSIPATION = 3.5,
          VELOCITY_DISSIPATION = 2,
          PRESSURE = 0.1,
          PRESSURE_ITERATIONS = 20,
          CURL = 3,
          SPLAT_RADIUS = 0.2,
          SPLAT_FORCE = 6000,
          SHADING = true,
          COLOR_UPDATE_SPEED = 10,
          BACK_COLOR = { r: 0, g: 0, b: 0 },
          TRANSPARENT = true,
        }) {
          const canvasRef = useRef(null);

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;

            // Make canvas fill the screen
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            function pointerPrototype() {
              this.id = -1;
              this.texcoordX = 0;
              this.texcoordY = 0;
              this.prevTexcoordX = 0;
              this.prevTexcoordY = 0;
              this.deltaX = 0;
              this.deltaY = 0;
              this.down = false;
              this.moved = false;
              this.color = [30, 0, 300];
            }

            let pointers = [];
            let splatStack = [];
            pointers.push(new pointerPrototype());

            const { gl, ext } = getWebGLContext(canvas);

            if (isMobile()) {
                config.DYE_RESOLUTION = 512;
            }
            if (!ext.supportLinearFiltering) {
                config.DYE_RESOLUTION = 512;
                config.SHADING = false;
                config.BLOOM = false;
                config.SUNRAYS = false;
            }

            function getWebGLContext(canvas) {
              const params = {
                alpha: true,
                depth: false,
                stencil: false,
                antialias: false,
                preserveDrawingBuffer: false,
              };
              
              let gl = canvas.getContext("webgl2", params);
              const isWebGL2 = !!gl;
              if (!isWebGL2)
                gl =
                  canvas.getContext("webgl", params) ||
                  canvas.getContext("experimental-webgl", params);

              let halfFloat;
              let supportLinearFiltering;
              if (isWebGL2) {
                gl.getExtension("EXT_color_buffer_float");
                supportLinearFiltering = gl.getExtension("OES_texture_float_linear");
              } else {
                halfFloat = gl.getExtension("OES_texture_half_float");
                supportLinearFiltering = gl.getExtension("OES_texture_half_float_linear");
              }

              gl.clearColor(0.0, 0.0, 0.0, 1.0);

              const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;
              let formatRGBA;
              let formatRG;
              let formatR;

              if (isWebGL2) {
                formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
                formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
                formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
              } else {
                formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
              }

              return {
                gl,
                ext: {
                  formatRGBA,
                  formatRG,
                  formatR,
                  halfFloatTexType,
                  supportLinearFiltering,
                },
              };
            }

            function getSupportedFormat(gl, internalFormat, format, type) {
              if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
                switch (internalFormat) {
                  case gl.R16F:
                    return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
                  case gl.RG16F:
                    return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
                  default:
                    return null;
                }
              }
              return { internalFormat, format };
            }

            function supportRenderTextureFormat(gl, internalFormat, format, type) {
              const texture = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);

              const fbo = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

              const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
              return status === gl.FRAMEBUFFER_COMPLETE;
            }

            function isMobile() {
              return /Mobi|Android/i.test(navigator.userAgent);
            }

            // Additional fluid simulation setup would go here
            // ...

            // Setup canvas mouse/touch interactivity
            canvas.addEventListener('mousemove', (e) => {
              const pointer = pointers[0];
              if (!pointer.down) return;
              const posX = e.offsetX;
              const posY = e.offsetY;
              updatePointerMoveData(pointer, posX, posY);
            });

            canvas.addEventListener('touchmove', (e) => {
              e.preventDefault();
              const touches = e.targetTouches;
              for (let i = 0; i < touches.length; i++) {
                const pointer = pointers[i];
                if (!pointer) continue;
                updatePointerMoveData(pointer, touches[i].pageX, touches[i].pageY);
              }
            }, false);
            
            canvas.addEventListener('mousedown', () => {
              const pointer = pointers[0];
              pointer.down = true;
              pointer.color = generateColor();
            });
            
            canvas.addEventListener('touchstart', (e) => {
              e.preventDefault();
              const touches = e.targetTouches;
              for (let i = 0; i < touches.length; i++) {
                if (i >= pointers.length) {
                  pointers.push(new pointerPrototype());
                }
                const pointer = pointers[i];
                pointer.down = true;
                pointer.color = generateColor();
                updatePointerMoveData(pointer, touches[i].pageX, touches[i].pageY);
              }
            }, false);
            
            window.addEventListener('mouseup', () => {
              const pointer = pointers[0];
              pointer.down = false;
            });

            window.addEventListener('touchend', (e) => {
              const touches = e.targetTouches;
              for (let i = 0; i < pointers.length; i++) {
                if (i >= touches.length) {
                  pointers[i].down = false;
                }
              }
            });

            function generateColor() {
              let c = HSVtoRGB(Math.random(), 1.0, 1.0);
              c.r *= 0.15;
              c.g *= 0.15;
              c.b *= 0.15;
              return c;
            }

            function HSVtoRGB(h, s, v) {
              let r, g, b, i, f, p, q, t;
              i = Math.floor(h * 6);
              f = h * 6 - i;
              p = v * (1 - s);
              q = v * (1 - f * s);
              t = v * (1 - (1 - f) * s);

              switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
              }

              return {
                r,
                g,
                b
              };
            }

            function updatePointerMoveData(pointer, posX, posY) {
              pointer.prevTexcoordX = pointer.texcoordX;
              pointer.prevTexcoordY = pointer.texcoordY;
              pointer.texcoordX = posX / canvas.width;
              pointer.texcoordY = 1.0 - posY / canvas.height;
              pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);
              pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);
              pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;
            }

            function correctDeltaX(delta) {
              let aspectRatio = canvas.width / canvas.height;
              if (aspectRatio < 1) delta *= aspectRatio;
              return delta;
            }

            function correctDeltaY(delta) {
              let aspectRatio = canvas.width / canvas.height;
              if (aspectRatio > 1) delta /= aspectRatio;
              return delta;
            }

            // Animation loop would be set up here
            // ...

          }, []); // Empty dependency array means this effect runs once on mount

          return <canvas ref={canvasRef} />;
        }
        
        // Render the SplashCursor component
        const root = ReactDOM.createRoot(document.getElementById('splash-cursor'));
        root.render(<SplashCursor />);
    </script>
</body>
</html>