<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="../assets/images/favicon.ico">
    <!-- CSS -->
    <link rel="stylesheet" href="../assets/css/reset.css">
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/animations.css">
    <title>é¢éƒ¨è¿½è¸ªå™¨ | Face Tracker</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-cyan: #00f5ff;
            --primary-magenta: #ff00ff;
            --primary-yellow: #ffff00;
            --bg-dark: #0a0a12;
            --bg-darker: #050508;
            --glass-bg: rgba(10, 10, 18, 0.85);
            --border-glow: rgba(0, 245, 255, 0.3);
        }
        
        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--bg-dark);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* åŠ¨æ€ç½‘æ ¼èƒŒæ™¯ */
        .grid-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 245, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 245, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            animation: gridMove 20s linear infinite;
            pointer-events: none;
        }
        
        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(40px, 40px); }
        }
        
        /* æ‰«æçº¿æ•ˆæœ */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 1000;
        }
        
        /* ä¸»è§†é¢‘å®¹å™¨ */
        .main-view {
            position: relative;
            width: 900px;
            height: 680px;
            background: var(--bg-darker);
            border: 2px solid var(--border-glow);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 
                0 0 60px rgba(0, 245, 255, 0.15),
                inset 0 0 100px rgba(0, 0, 0, 0.5);
        }
        
        .main-view::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--primary-cyan), var(--primary-magenta), var(--primary-yellow));
            border-radius: 22px;
            z-index: -1;
            opacity: 0.5;
            filter: blur(15px);
            animation: borderGlow 4s ease-in-out infinite alternate;
        }
        
        @keyframes borderGlow {
            0% { opacity: 0.3; }
            100% { opacity: 0.7; }
        }
        
        #videoElement {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0;
        }
        
        #mainCanvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #overlayCanvas {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        
        /* é¡¶éƒ¨çŠ¶æ€æ  */
        .status-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            background: var(--glass-bg);
            padding: 12px 25px;
            border-radius: 50px;
            border: 1px solid var(--border-glow);
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px #ff3333;
            transition: all 0.3s ease;
        }
        
        .status-dot.active {
            background: #00ff88;
            box-shadow: 0 0 15px #00ff88;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        .status-text {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        /* ä¾§è¾¹é¢æ¿ */
        .side-panel {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 50;
        }
        
        .panel-card {
            background: var(--glass-bg);
            border: 1px solid var(--border-glow);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(15px);
        }
        
        .panel-title {
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            letter-spacing: 3px;
            color: var(--primary-cyan);
            margin-bottom: 15px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-title::before {
            content: '';
            width: 20px;
            height: 2px;
            background: linear-gradient(90deg, var(--primary-cyan), transparent);
        }
        
        /* è¡¨æƒ…æ˜¾ç¤º */
        .expression-display {
            text-align: center;
        }
        
        .expression-emoji {
            font-size: 60px;
            margin-bottom: 10px;
            filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.3));
            animation: floatEmoji 3s ease-in-out infinite;
        }
        
        @keyframes floatEmoji {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .expression-name {
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .expression-confidence {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary-cyan);
        }
        
        /* æ•°æ®æŒ‡æ ‡ */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .metric-item {
            background: rgba(0, 245, 255, 0.05);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }
        
        .metric-value {
            font-family: 'Orbitron', monospace;
            font-size: 20px;
            font-weight: 700;
            color: var(--primary-cyan);
        }
        
        .metric-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
        }
        
        /* æ§åˆ¶æŒ‰é’® */
        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }
        
        .control-btn {
            background: var(--glass-bg);
            border: 1px solid var(--border-glow);
            color: #fff;
            padding: 12px 25px;
            border-radius: 50px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            border-color: var(--primary-cyan);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 245, 255, 0.2);
        }
        
        .control-btn.active {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.3), rgba(255, 0, 255, 0.3));
            border-color: var(--primary-magenta);
        }
        
        /* å·¦ä¾§ä¿¡æ¯é¢æ¿ */
        .info-panel {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 260px;
            z-index: 50;
        }
        
        .landmark-count {
            font-family: 'Orbitron', monospace;
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(135deg, var(--primary-cyan), var(--primary-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
        }
        
        .landmark-label {
            font-size: 12px;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            margin-top: 5px;
        }
        
        /* å¤´åƒé¢„è§ˆ */
        .avatar-preview {
            margin-top: 25px;
        }
        
        #avatarCanvas {
            width: 100%;
            height: 180px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(0, 245, 255, 0.2);
        }
        
        /* æ¸²æŸ“æ¨¡å¼åˆ‡æ¢ */
        .render-modes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
        }
        
        .mode-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .mode-btn:hover {
            border-color: var(--primary-cyan);
            color: var(--primary-cyan);
        }
        
        .mode-btn.active {
            background: var(--primary-cyan);
            border-color: var(--primary-cyan);
            color: var(--bg-dark);
        }
        
        /* åŠ è½½åŠ¨ç”» */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-darker);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            transition: opacity 0.5s ease;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 3px solid transparent;
            border-top-color: var(--primary-cyan);
            border-right-color: var(--primary-magenta);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            letter-spacing: 4px;
            margin-top: 25px;
            color: var(--primary-cyan);
            animation: blink 1s ease-in-out infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* è§’è½è£…é¥° */
        .corner-decor {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 2px solid var(--primary-cyan);
            opacity: 0.5;
        }
        
        .corner-decor.top-left {
            top: 15px;
            left: 15px;
            border-right: none;
            border-bottom: none;
        }
        
        .corner-decor.top-right {
            top: 15px;
            right: 15px;
            border-left: none;
            border-bottom: none;
        }
        
        .corner-decor.bottom-left {
            bottom: 15px;
            left: 15px;
            border-right: none;
            border-top: none;
        }
        
        .corner-decor.bottom-right {
            bottom: 15px;
            right: 15px;
            border-left: none;
            border-top: none;
        }
        
        /* å“åº”å¼ */
        @media (max-width: 1400px) {
            .side-panel, .info-panel {
                display: none;
            }
            .main-view {
                width: 95vw;
                height: 70vh;
            }
        }
    </style>
</head>
<body>
    <header>
        <a href="../index.html" class="logo">
            <img src="../assets/images/favicon.ico" alt="favicon" class="nav-favicon">
            <span class="artistic-text">
                <span class="letter">E</span>
                <span class="letter">d</span>
                <span class="letter">d</span>
                <span class="letter">i</span>
                <span class="letter">e</span>
            </span>
        </a>
        <div class="dropdown center-menu">
            <button class="dropbtn">Menu</button>
            <div class="dropdown-content">
                <a href="../research.html">My Research</a>
                <a href="../project.html">My Project</a>
                <a href="../life.html">My Life</a>
            </div>
        </div>
        <nav class="navbar">
            <a href="../index.html#Past">Past</a>
            <a href="../index.html#Present">Present</a>
            <a href="../index.html#Future">Future</a>
        </nav>
    </header>

    <div id="container">
        <div class="grid-bg"></div>
        <div class="scanlines"></div>
        
        <!-- å·¦ä¾§ä¿¡æ¯é¢æ¿ -->
        <div class="info-panel">
            <div class="panel-card">
                <div class="panel-title">é¢éƒ¨ç½‘æ ¼æ•°æ®</div>
                <div class="landmark-count" id="landmarkCount">0</div>
                <div class="landmark-label">æ£€æµ‹åˆ°çš„å…³é”®ç‚¹</div>
                
                <div class="avatar-preview">
                    <div class="panel-title">è™šæ‹Ÿå¤´åƒ</div>
                    <canvas id="avatarCanvas"></canvas>
                </div>
                
                <div class="render-modes">
                    <button class="mode-btn active" data-mode="mesh">ç½‘æ ¼</button>
                    <button class="mode-btn" data-mode="points">ç‚¹é˜µ</button>
                    <button class="mode-btn" data-mode="contour">è½®å»“</button>
                    <button class="mode-btn" data-mode="heatmap">çƒ­åŠ›å›¾</button>
                </div>
            </div>
        </div>
        
        <!-- ä¸»è§†é¢‘åŒºåŸŸ -->
        <div class="main-view">
            <div class="corner-decor top-left"></div>
            <div class="corner-decor top-right"></div>
            <div class="corner-decor bottom-left"></div>
            <div class="corner-decor bottom-right"></div>
            
            <video id="videoElement" autoplay playsinline></video>
            <canvas id="mainCanvas"></canvas>
            <canvas id="overlayCanvas"></canvas>
            
            <div class="status-bar">
                <div class="status-dot" id="statusDot"></div>
                <span class="status-text" id="statusText">åˆå§‹åŒ–ä¸­...</span>
            </div>
            
            <div class="loading-overlay" id="loadingOverlay">
                <div class="loading-spinner"></div>
                <div class="loading-text">æ­£åœ¨åŠ è½½é¢éƒ¨è¯†åˆ«æ¨¡å‹</div>
            </div>
        </div>
        
        <!-- å³ä¾§é¢æ¿ -->
        <div class="side-panel">
            <div class="panel-card expression-display">
                <div class="panel-title">å½“å‰è¡¨æƒ…</div>
                <div class="expression-emoji" id="expressionEmoji">ğŸ˜</div>
                <div class="expression-name" id="expressionName">ä¸­æ€§</div>
                <div class="expression-confidence" id="expressionConfidence">0%</div>
            </div>
            
            <div class="panel-card">
                <div class="panel-title">é¢éƒ¨æŒ‡æ ‡</div>
                <div class="metrics-grid">
                    <div class="metric-item">
                        <div class="metric-value" id="mouthOpenness">0</div>
                        <div class="metric-label">å˜´å·´å¼ åº¦</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" id="eyeOpenness">0</div>
                        <div class="metric-label">çœ¼ç›å¼ åº¦</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" id="browRaise">0</div>
                        <div class="metric-label">çœ‰æ¯›é«˜åº¦</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-value" id="headTilt">0Â°</div>
                        <div class="metric-label">å¤´éƒ¨å€¾æ–œ</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- åº•éƒ¨æ§åˆ¶ -->
        <div class="controls">
            <button class="control-btn" id="toggleCamera">
                <span>ğŸ“·</span> åˆ‡æ¢æ‘„åƒå¤´
            </button>
            <button class="control-btn" id="toggleVideo">
                <span>ğŸ¬</span> æ˜¾ç¤ºè§†é¢‘
            </button>
            <button class="control-btn" id="captureBtn">
                <span>ğŸ“¸</span> æˆªå›¾ä¿å­˜
            </button>
            <button class="control-btn" id="exportBtn">
                <span>ğŸ’¾</span> å¯¼å‡ºæ•°æ®
            </button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
    <script>
        // é…ç½®
        const CONFIG = {
            scaleFactor: 1.0,
            pointSize: 2,
            lineWidth: 1,
            showMesh: true,
            showPoints: false,
            showContour: false,
            showHeatmap: false,
            videoOpacity: 0
        };
        
        // è¡¨æƒ…å®šä¹‰
        const EXPRESSIONS = {
            neutral: { name: 'ä¸­æ€§', emoji: 'ğŸ˜', color: '#888888' },
            happy: { name: 'å¼€å¿ƒ', emoji: 'ğŸ˜„', color: '#ffd700' },
            sad: { name: 'æ‚²ä¼¤', emoji: 'ğŸ˜¢', color: '#4169e1' },
            angry: { name: 'ç”Ÿæ°”', emoji: 'ğŸ˜ ', color: '#ff4500' },
            surprised: { name: 'æƒŠè®¶', emoji: 'ğŸ˜²', color: '#ff69b4' },
            fearful: { name: 'ææƒ§', emoji: 'ğŸ˜¨', color: '#9932cc' }
        };
        
        // é¢éƒ¨ç½‘æ ¼è¿æ¥ï¼ˆç®€åŒ–ç‰ˆï¼‰
        const FACE_MESH_CONNECTIONS = {
            // é¢éƒ¨è½®å»“
            silhouette: [
                [10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389],
                [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397],
                [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152],
                [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172],
                [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162],
                [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]
            ],
            // å·¦çœ¼
            leftEye: [
                [33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154],
                [154, 155], [155, 133], [133, 173], [173, 157], [157, 158], [158, 159],
                [159, 160], [160, 161], [161, 246], [246, 33]
            ],
            // å³çœ¼
            rightEye: [
                [362, 382], [382, 381], [381, 380], [380, 374], [374, 373], [373, 390],
                [390, 249], [249, 263], [263, 466], [466, 388], [388, 387], [387, 386],
                [386, 385], [385, 384], [384, 398], [398, 362]
            ],
            // å·¦çœ‰
            leftBrow: [
                [46, 53], [53, 52], [52, 65], [65, 55], [55, 107], [107, 66],
                [66, 105], [105, 63], [63, 70]
            ],
            // å³çœ‰
            rightBrow: [
                [276, 283], [283, 282], [282, 295], [295, 285], [285, 336], [336, 296],
                [296, 334], [334, 293], [293, 300]
            ],
            // å˜´å”‡å¤–åœˆ
            lipsOuter: [
                [61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314],
                [314, 405], [405, 321], [321, 375], [375, 291], [291, 409], [409, 270],
                [270, 269], [269, 267], [267, 0], [0, 37], [37, 39], [39, 40],
                [40, 185], [185, 61]
            ],
            // å˜´å”‡å†…åœˆ
            lipsInner: [
                [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317],
                [317, 402], [402, 318], [318, 324], [324, 308], [308, 415], [415, 310],
                [310, 311], [311, 312], [312, 13], [13, 82], [82, 81], [81, 80],
                [80, 191], [191, 78]
            ],
            // é¼»å­
            nose: [
                [168, 6], [6, 197], [197, 195], [195, 5], [5, 4], [4, 1],
                [1, 19], [19, 94], [94, 2]
            ]
        };
        
        // å…³é”®ç‚¹ç´¢å¼•
        const KEY_POINTS = {
            noseTip: 4,
            leftEyeInner: 133,
            leftEyeOuter: 33,
            rightEyeInner: 362,
            rightEyeOuter: 263,
            mouthTop: 13,
            mouthBottom: 14,
            leftEyeTop: 159,
            leftEyeBottom: 145,
            rightEyeTop: 386,
            rightEyeBottom: 374,
            leftBrowInner: 107,
            rightBrowInner: 336,
            chin: 152
        };
        
        // DOM å…ƒç´ 
        const video = document.getElementById('videoElement');
        const mainCanvas = document.getElementById('mainCanvas');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const avatarCanvas = document.getElementById('avatarCanvas');
        const loadingOverlay = document.getElementById('loadingOverlay');
        
        const mainCtx = mainCanvas.getContext('2d');
        const overlayCtx = overlayCanvas.getContext('2d');
        const avatarCtx = avatarCanvas.getContext('2d');
        
        // çŠ¶æ€å˜é‡
        let currentFaceLandmarks = null;
        let currentExpression = 'neutral';
        let expressionConfidence = 0;
        let facingMode = 'user';
        let renderMode = 'mesh';
        let camera = null;
        
        // åˆå§‹åŒ–ç”»å¸ƒå°ºå¯¸
        function initCanvases() {
            const container = document.querySelector('.main-view');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            mainCanvas.width = width;
            mainCanvas.height = height;
            overlayCanvas.width = width;
            overlayCanvas.height = height;
            
            avatarCanvas.width = avatarCanvas.clientWidth;
            avatarCanvas.height = avatarCanvas.clientHeight;
        }
        
        // åˆå§‹åŒ– MediaPipe Face Mesh
        async function initFaceMesh() {
            const faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onFaceMeshResults);
            
            return faceMesh;
        }
        
        // åˆå§‹åŒ–æ‘„åƒå¤´
        async function initCamera(faceMesh) {
            camera = new Camera(video, {
                onFrame: async () => {
                    await faceMesh.send({ image: video });
                },
                width: 1280,
                height: 720,
                facingMode: facingMode
            });
            
            await camera.start();
            loadingOverlay.classList.add('hidden');
            updateStatus('é¢éƒ¨è¿½è¸ªå·²å¯åŠ¨', true);
        }
        
        // å¤„ç†é¢éƒ¨ç½‘æ ¼ç»“æœ
        function onFaceMeshResults(results) {
            // æ¸…é™¤ç”»å¸ƒ
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            drawBackground();
            
            // ç»˜åˆ¶è§†é¢‘å¸§ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            if (CONFIG.videoOpacity > 0) {
                mainCtx.globalAlpha = CONFIG.videoOpacity;
                mainCtx.save();
                mainCtx.scale(-1, 1);
                mainCtx.drawImage(results.image, -mainCanvas.width, 0, mainCanvas.width, mainCanvas.height);
                mainCtx.restore();
                mainCtx.globalAlpha = 1;
            }
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                currentFaceLandmarks = results.multiFaceLandmarks[0];
                
                // æ›´æ–°å…³é”®ç‚¹è®¡æ•°
                document.getElementById('landmarkCount').textContent = currentFaceLandmarks.length;
                
                // æ ¹æ®æ¸²æŸ“æ¨¡å¼ç»˜åˆ¶
                switch (renderMode) {
                    case 'mesh':
                        drawFaceMesh();
                        break;
                    case 'points':
                        drawFacePoints();
                        break;
                    case 'contour':
                        drawFaceContours();
                        break;
                    case 'heatmap':
                        drawHeatmap();
                        break;
                }
                
                // åˆ†æè¡¨æƒ…
                analyzeExpression();
                
                // æ›´æ–°æŒ‡æ ‡
                updateMetrics();
                
                // ç»˜åˆ¶è™šæ‹Ÿå¤´åƒ
                drawAvatar();
            } else {
                currentFaceLandmarks = null;
                document.getElementById('landmarkCount').textContent = '0';
            }
        }
        
        // ç»˜åˆ¶èƒŒæ™¯
        function drawBackground() {
            const gradient = mainCtx.createLinearGradient(0, 0, mainCanvas.width, mainCanvas.height);
            gradient.addColorStop(0, '#0a0a12');
            gradient.addColorStop(0.5, '#0f1525');
            gradient.addColorStop(1, '#0a0a12');
            
            mainCtx.fillStyle = gradient;
            mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
            
            // ç½‘æ ¼æ•ˆæœ
            mainCtx.strokeStyle = 'rgba(0, 245, 255, 0.03)';
            mainCtx.lineWidth = 1;
            
            const gridSize = 30;
            for (let x = 0; x < mainCanvas.width; x += gridSize) {
                mainCtx.beginPath();
                mainCtx.moveTo(x, 0);
                mainCtx.lineTo(x, mainCanvas.height);
                mainCtx.stroke();
            }
            for (let y = 0; y < mainCanvas.height; y += gridSize) {
                mainCtx.beginPath();
                mainCtx.moveTo(0, y);
                mainCtx.lineTo(mainCanvas.width, y);
                mainCtx.stroke();
            }
        }
        
        // ç»˜åˆ¶é¢éƒ¨ç½‘æ ¼
        function drawFaceMesh() {
            if (!currentFaceLandmarks) return;
            
            // ç»˜åˆ¶æ‰€æœ‰è¿æ¥çº¿
            Object.entries(FACE_MESH_CONNECTIONS).forEach(([region, connections]) => {
                let color, lineWidth;
                
                switch (region) {
                    case 'leftEye':
                    case 'rightEye':
                        color = 'rgba(0, 255, 255, 0.8)';
                        lineWidth = 2;
                        break;
                    case 'leftBrow':
                    case 'rightBrow':
                        color = 'rgba(255, 200, 0, 0.7)';
                        lineWidth = 2;
                        break;
                    case 'lipsOuter':
                        color = 'rgba(255, 100, 150, 0.8)';
                        lineWidth = 2;
                        break;
                    case 'lipsInner':
                        color = 'rgba(255, 50, 100, 0.9)';
                        lineWidth = 1.5;
                        break;
                    case 'nose':
                        color = 'rgba(255, 255, 100, 0.6)';
                        lineWidth = 1.5;
                        break;
                    case 'silhouette':
                        color = 'rgba(0, 245, 255, 0.5)';
                        lineWidth = 1.5;
                        break;
                    default:
                        color = 'rgba(0, 245, 255, 0.3)';
                        lineWidth = 1;
                }
                
                overlayCtx.strokeStyle = color;
                overlayCtx.lineWidth = lineWidth;
                overlayCtx.lineJoin = 'round';
                overlayCtx.lineCap = 'round';
                
                connections.forEach(([startIdx, endIdx]) => {
                    const start = getLandmarkPosition(startIdx);
                    const end = getLandmarkPosition(endIdx);
                    
                    overlayCtx.beginPath();
                    overlayCtx.moveTo(start.x, start.y);
                    overlayCtx.lineTo(end.x, end.y);
                    overlayCtx.stroke();
                });
            });
            
            // ç»˜åˆ¶å…³é”®ç‚¹
            drawKeyPoints();
        }
        
        // ç»˜åˆ¶é¢éƒ¨ç‚¹é˜µ
        function drawFacePoints() {
            if (!currentFaceLandmarks) return;
            
            currentFaceLandmarks.forEach((landmark, index) => {
                const pos = getLandmarkPosition(index);
                
                // æ ¹æ®æ·±åº¦å€¼è®¾ç½®é¢œè‰²å’Œå¤§å°
                const depth = landmark.z;
                const size = Math.max(1, 3 - depth * 50);
                const alpha = Math.max(0.3, 1 - Math.abs(depth) * 10);
                
                let hue = 180 + depth * 500; // ä»é’è‰²åˆ°ç´«è‰²
                overlayCtx.fillStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;
                
                overlayCtx.beginPath();
                overlayCtx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                overlayCtx.fill();
            });
        }
        
        // ç»˜åˆ¶é¢éƒ¨è½®å»“
        function drawFaceContours() {
            if (!currentFaceLandmarks) return;
            
            // åªç»˜åˆ¶ä¸»è¦è½®å»“
            const contourRegions = ['silhouette', 'leftEye', 'rightEye', 'lipsOuter', 'nose'];
            
            contourRegions.forEach(region => {
                const connections = FACE_MESH_CONNECTIONS[region];
                if (!connections) return;
                
                let color;
                switch (region) {
                    case 'silhouette':
                        color = '#00f5ff';
                        break;
                    case 'leftEye':
                    case 'rightEye':
                        color = '#ff00ff';
                        break;
                    case 'lipsOuter':
                        color = '#ff4488';
                        break;
                    case 'nose':
                        color = '#ffff00';
                        break;
                }
                
                overlayCtx.strokeStyle = color;
                overlayCtx.lineWidth = 3;
                overlayCtx.shadowColor = color;
                overlayCtx.shadowBlur = 15;
                
                overlayCtx.beginPath();
                connections.forEach(([startIdx, endIdx], i) => {
                    const start = getLandmarkPosition(startIdx);
                    const end = getLandmarkPosition(endIdx);
                    
                    if (i === 0) {
                        overlayCtx.moveTo(start.x, start.y);
                    }
                    overlayCtx.lineTo(end.x, end.y);
                });
                overlayCtx.stroke();
                overlayCtx.shadowBlur = 0;
            });
        }
        
        // ç»˜åˆ¶çƒ­åŠ›å›¾
        function drawHeatmap() {
            if (!currentFaceLandmarks) return;
            
            // åˆ›å»ºçƒ­åŠ›å›¾
            currentFaceLandmarks.forEach((landmark, index) => {
                const pos = getLandmarkPosition(index);
                
                // æ ¹æ®é¢éƒ¨åŒºåŸŸå’Œæ·±åº¦åˆ›å»ºçƒ­åŠ›æ•ˆæœ
                let intensity;
                if (index >= 61 && index <= 291) { // å˜´å·´åŒºåŸŸ
                    intensity = 1.0;
                } else if (isEyeRegion(index)) {
                    intensity = 0.9;
                } else if (isBrowRegion(index)) {
                    intensity = 0.7;
                } else {
                    intensity = 0.5;
                }
                
                const gradient = overlayCtx.createRadialGradient(
                    pos.x, pos.y, 0,
                    pos.x, pos.y, 15 * intensity
                );
                
                const hue = 60 - intensity * 60; // ä»é»„è‰²åˆ°çº¢è‰²
                gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, ${intensity * 0.6})`);
                gradient.addColorStop(1, `hsla(${hue}, 100%, 50%, 0)`);
                
                overlayCtx.fillStyle = gradient;
                overlayCtx.fillRect(pos.x - 20, pos.y - 20, 40, 40);
            });
        }
        
        // ç»˜åˆ¶å…³é”®ç‚¹
        function drawKeyPoints() {
            if (!currentFaceLandmarks) return;
            
            Object.entries(KEY_POINTS).forEach(([name, index]) => {
                const pos = getLandmarkPosition(index);
                
                // å¤–åœˆå‘å…‰æ•ˆæœ
                overlayCtx.beginPath();
                overlayCtx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
                overlayCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                overlayCtx.fill();
                
                // å†…åœˆ
                overlayCtx.beginPath();
                overlayCtx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
                overlayCtx.fillStyle = '#ffffff';
                overlayCtx.fill();
            });
        }
        
        // è·å–å…³é”®ç‚¹ä½ç½®ï¼ˆå±å¹•åæ ‡ï¼‰
        function getLandmarkPosition(index) {
            const landmark = currentFaceLandmarks[index];
            return {
                x: (1 - landmark.x) * overlayCanvas.width,
                y: landmark.y * overlayCanvas.height,
                z: landmark.z
            };
        }
        
        // åˆ¤æ–­æ˜¯å¦ä¸ºçœ¼ç›åŒºåŸŸ
        function isEyeRegion(index) {
            return (index >= 33 && index <= 173) || (index >= 249 && index <= 398);
        }
        
        // åˆ¤æ–­æ˜¯å¦ä¸ºçœ‰æ¯›åŒºåŸŸ
        function isBrowRegion(index) {
            return (index >= 46 && index <= 107) || (index >= 276 && index <= 336);
        }
        
        // åˆ†æè¡¨æƒ…
        function analyzeExpression() {
            if (!currentFaceLandmarks) return;
            
            // è®¡ç®—é¢éƒ¨ç‰¹å¾
            const mouthOpen = calculateMouthOpenness();
            const eyeOpen = calculateEyeOpenness();
            const browRaise = calculateBrowRaise();
            
            // ç®€å•çš„è¡¨æƒ…åˆ†ç±»
            let expression = 'neutral';
            let confidence = 70;
            
            if (mouthOpen > 0.15) {
                if (browRaise > 0.05) {
                    expression = 'surprised';
                    confidence = Math.min(95, 70 + mouthOpen * 100 + browRaise * 200);
                } else {
                    expression = 'happy';
                    confidence = Math.min(95, 70 + mouthOpen * 100);
                }
            } else if (browRaise < -0.03) {
                expression = 'angry';
                confidence = Math.min(90, 70 - browRaise * 300);
            } else if (eyeOpen < 0.02) {
                expression = 'sad';
                confidence = Math.min(85, 70 + (0.03 - eyeOpen) * 500);
            }
            
            currentExpression = expression;
            expressionConfidence = confidence;
            
            // æ›´æ–° UI
            const expr = EXPRESSIONS[expression];
            document.getElementById('expressionEmoji').textContent = expr.emoji;
            document.getElementById('expressionName').textContent = expr.name;
            document.getElementById('expressionName').style.color = expr.color;
            document.getElementById('expressionConfidence').textContent = confidence.toFixed(0) + '%';
        }
        
        // è®¡ç®—å˜´å·´å¼ åº¦
        function calculateMouthOpenness() {
            const top = getLandmarkPosition(KEY_POINTS.mouthTop);
            const bottom = getLandmarkPosition(KEY_POINTS.mouthBottom);
            const distance = Math.abs(bottom.y - top.y);
            return distance / overlayCanvas.height;
        }
        
        // è®¡ç®—çœ¼ç›å¼ åº¦
        function calculateEyeOpenness() {
            const leftTop = getLandmarkPosition(KEY_POINTS.leftEyeTop);
            const leftBottom = getLandmarkPosition(KEY_POINTS.leftEyeBottom);
            const rightTop = getLandmarkPosition(KEY_POINTS.rightEyeTop);
            const rightBottom = getLandmarkPosition(KEY_POINTS.rightEyeBottom);
            
            const leftOpen = Math.abs(leftBottom.y - leftTop.y);
            const rightOpen = Math.abs(rightBottom.y - rightTop.y);
            
            return (leftOpen + rightOpen) / 2 / overlayCanvas.height;
        }
        
        // è®¡ç®—çœ‰æ¯›æŠ¬èµ·ç¨‹åº¦
        function calculateBrowRaise() {
            const leftBrow = getLandmarkPosition(KEY_POINTS.leftBrowInner);
            const rightBrow = getLandmarkPosition(KEY_POINTS.rightBrowInner);
            const noseTip = getLandmarkPosition(KEY_POINTS.noseTip);
            
            const avgBrowY = (leftBrow.y + rightBrow.y) / 2;
            const normalizedDistance = (noseTip.y - avgBrowY) / overlayCanvas.height;
            
            return normalizedDistance - 0.1; // åŸºå‡†åç§»
        }
        
        // æ›´æ–°æŒ‡æ ‡æ˜¾ç¤º
        function updateMetrics() {
            if (!currentFaceLandmarks) return;
            
            const mouthOpen = calculateMouthOpenness();
            const eyeOpen = calculateEyeOpenness();
            const browRaise = calculateBrowRaise();
            
            // è®¡ç®—å¤´éƒ¨å€¾æ–œ
            const leftEye = getLandmarkPosition(KEY_POINTS.leftEyeOuter);
            const rightEye = getLandmarkPosition(KEY_POINTS.rightEyeOuter);
            const headTilt = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x) * 180 / Math.PI;
            
            document.getElementById('mouthOpenness').textContent = (mouthOpen * 100).toFixed(0);
            document.getElementById('eyeOpenness').textContent = (eyeOpen * 100).toFixed(0);
            document.getElementById('browRaise').textContent = (browRaise * 100).toFixed(0);
            document.getElementById('headTilt').textContent = headTilt.toFixed(1) + 'Â°';
        }
        
        // ç»˜åˆ¶è™šæ‹Ÿå¤´åƒ
        function drawAvatar() {
            avatarCtx.clearRect(0, 0, avatarCanvas.width, avatarCanvas.height);
            
            const centerX = avatarCanvas.width / 2;
            const centerY = avatarCanvas.height / 2;
            const headRadius = 60;
            
            // å¤´éƒ¨èƒŒæ™¯
            const headGradient = avatarCtx.createRadialGradient(
                centerX - 20, centerY - 20, 0,
                centerX, centerY, headRadius
            );
            headGradient.addColorStop(0, '#ffd8b1');
            headGradient.addColorStop(1, '#e8c090');
            
            avatarCtx.beginPath();
            avatarCtx.arc(centerX, centerY, headRadius, 0, Math.PI * 2);
            avatarCtx.fillStyle = headGradient;
            avatarCtx.fill();
            avatarCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            avatarCtx.lineWidth = 2;
            avatarCtx.stroke();
            
            // æ ¹æ®å½“å‰è¡¨æƒ…ç»˜åˆ¶é¢éƒ¨ç‰¹å¾
            drawAvatarEyes(centerX, centerY, currentExpression);
            drawAvatarBrows(centerX, centerY, currentExpression);
            drawAvatarMouth(centerX, centerY, currentExpression);
            
            // è¡¨æƒ…æ ‡ç­¾
            avatarCtx.fillStyle = EXPRESSIONS[currentExpression].color;
            avatarCtx.font = 'bold 12px Orbitron';
            avatarCtx.textAlign = 'center';
            avatarCtx.fillText(EXPRESSIONS[currentExpression].name, centerX, centerY + headRadius + 20);
        }
        
        // ç»˜åˆ¶å¤´åƒçœ¼ç›
        function drawAvatarEyes(cx, cy, expression) {
            const eyeY = cy - 10;
            const eyeSpacing = 22;
            
            [-1, 1].forEach(side => {
                const eyeX = cx + side * eyeSpacing;
                
                // çœ¼ç™½
                avatarCtx.beginPath();
                avatarCtx.ellipse(eyeX, eyeY, 10, expression === 'surprised' ? 12 : 8, 0, 0, Math.PI * 2);
                avatarCtx.fillStyle = '#ffffff';
                avatarCtx.fill();
                avatarCtx.strokeStyle = '#666';
                avatarCtx.lineWidth = 1;
                avatarCtx.stroke();
                
                // ç³å­”
                let pupilSize = expression === 'surprised' ? 4 : 6;
                let pupilColor = '#333';
                
                if (expression === 'happy') {
                    pupilColor = '#ffd700';
                } else if (expression === 'angry') {
                    pupilColor = '#ff4444';
                }
                
                avatarCtx.beginPath();
                avatarCtx.arc(eyeX, eyeY, pupilSize, 0, Math.PI * 2);
                avatarCtx.fillStyle = pupilColor;
                avatarCtx.fill();
                
                // é«˜å…‰
                avatarCtx.beginPath();
                avatarCtx.arc(eyeX - 2, eyeY - 2, 2, 0, Math.PI * 2);
                avatarCtx.fillStyle = '#fff';
                avatarCtx.fill();
                
                // æ‚²ä¼¤æ—¶çš„çœ¼ç‘
                if (expression === 'sad') {
                    avatarCtx.beginPath();
                    avatarCtx.ellipse(eyeX, eyeY - 5, 12, 6, 0, 0, Math.PI);
                    avatarCtx.fillStyle = '#ffd8b1';
                    avatarCtx.fill();
                }
            });
        }
        
        // ç»˜åˆ¶å¤´åƒçœ‰æ¯›
        function drawAvatarBrows(cx, cy, expression) {
            const browY = cy - 25;
            const browSpacing = 22;
            
            avatarCtx.strokeStyle = '#8b4513';
            avatarCtx.lineWidth = 3;
            avatarCtx.lineCap = 'round';
            
            [-1, 1].forEach(side => {
                const browX = cx + side * browSpacing;
                
                avatarCtx.save();
                avatarCtx.translate(browX, browY);
                
                let angle = 0;
                if (expression === 'angry') {
                    angle = side * 0.3;
                } else if (expression === 'surprised') {
                    angle = side * -0.2;
                } else if (expression === 'sad') {
                    angle = side * -0.4;
                }
                
                avatarCtx.rotate(angle);
                
                avatarCtx.beginPath();
                avatarCtx.moveTo(-10, 0);
                avatarCtx.quadraticCurveTo(0, expression === 'surprised' ? -8 : -3, 10, 0);
                avatarCtx.stroke();
                
                avatarCtx.restore();
            });
        }
        
        // ç»˜åˆ¶å¤´åƒå˜´å·´
        function drawAvatarMouth(cx, cy, expression) {
            const mouthY = cy + 25;
            
            avatarCtx.strokeStyle = '#cc6666';
            avatarCtx.lineWidth = 3;
            avatarCtx.lineCap = 'round';
            
            avatarCtx.beginPath();
            
            if (expression === 'happy') {
                avatarCtx.arc(cx, mouthY - 5, 15, 0.2 * Math.PI, 0.8 * Math.PI);
                avatarCtx.stroke();
                
                // èˆŒå¤´
                avatarCtx.beginPath();
                avatarCtx.arc(cx, mouthY + 3, 5, 0, Math.PI);
                avatarCtx.fillStyle = '#ff7777';
                avatarCtx.fill();
            } else if (expression === 'sad') {
                avatarCtx.arc(cx, mouthY + 10, 12, 1.2 * Math.PI, 1.8 * Math.PI);
                avatarCtx.stroke();
            } else if (expression === 'surprised') {
                avatarCtx.ellipse(cx, mouthY, 8, 12, 0, 0, Math.PI * 2);
                avatarCtx.fillStyle = '#cc4444';
                avatarCtx.fill();
            } else if (expression === 'angry') {
                avatarCtx.moveTo(cx - 15, mouthY);
                avatarCtx.lineTo(cx + 15, mouthY);
                avatarCtx.lineWidth = 4;
                avatarCtx.stroke();
            } else {
                avatarCtx.moveTo(cx - 12, mouthY);
                avatarCtx.quadraticCurveTo(cx, mouthY + 5, cx + 12, mouthY);
                avatarCtx.stroke();
            }
        }
        
        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(message, isActive) {
            document.getElementById('statusText').textContent = message;
            document.getElementById('statusDot').className = 'status-dot' + (isActive ? ' active' : '');
        }
        
        // æˆªå›¾åŠŸèƒ½
        function captureScreenshot() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = mainCanvas.width;
            tempCanvas.height = mainCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(mainCanvas, 0, 0);
            tempCtx.drawImage(overlayCanvas, 0, 0);
            
            const link = document.createElement('a');
            link.download = `face-mesh-${Date.now()}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }
        
        // å¯¼å‡ºæ•°æ®åŠŸèƒ½
        function exportData() {
            if (!currentFaceLandmarks) {
                alert('æ²¡æœ‰æ£€æµ‹åˆ°é¢éƒ¨æ•°æ®');
                return;
            }
            
            const data = {
                timestamp: new Date().toISOString(),
                expression: currentExpression,
                confidence: expressionConfidence,
                landmarks: currentFaceLandmarks.map(lm => ({
                    x: lm.x,
                    y: lm.y,
                    z: lm.z
                })),
                metrics: {
                    mouthOpenness: calculateMouthOpenness(),
                    eyeOpenness: calculateEyeOpenness(),
                    browRaise: calculateBrowRaise()
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `face-data-${Date.now()}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);
        }
        
        // åˆ‡æ¢æ‘„åƒå¤´
        async function toggleCamera() {
            facingMode = facingMode === 'user' ? 'environment' : 'user';
            if (camera) {
                camera.stop();
            }
            const faceMesh = await initFaceMesh();
            await initCamera(faceMesh);
        }
        
        // åˆ‡æ¢è§†é¢‘æ˜¾ç¤º
        function toggleVideo() {
            CONFIG.videoOpacity = CONFIG.videoOpacity > 0 ? 0 : 0.3;
            document.getElementById('toggleVideo').classList.toggle('active', CONFIG.videoOpacity > 0);
        }
        
        // äº‹ä»¶ç›‘å¬
        document.getElementById('toggleCamera').addEventListener('click', toggleCamera);
        document.getElementById('toggleVideo').addEventListener('click', toggleVideo);
        document.getElementById('captureBtn').addEventListener('click', captureScreenshot);
        document.getElementById('exportBtn').addEventListener('click', exportData);
        
        // æ¸²æŸ“æ¨¡å¼åˆ‡æ¢
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                renderMode = btn.dataset.mode;
            });
        });
        
        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', initCanvases);
        
        // åˆå§‹åŒ–
        async function init() {
            initCanvases();
            updateStatus('æ­£åœ¨åŠ è½½æ¨¡å‹...', false);
            
            try {
                const faceMesh = await initFaceMesh();
                await initCamera(faceMesh);
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                updateStatus('åˆå§‹åŒ–å¤±è´¥: ' + error.message, false);
                loadingOverlay.querySelector('.loading-text').textContent = 'åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
            }
        }
        
        init();
    </script>
</body>
</html>