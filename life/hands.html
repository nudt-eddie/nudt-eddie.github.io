<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ‰‹éƒ¨å®Œæ•´æ˜ å°„åˆ°å±å¹•</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video-container {
            position: absolute;
            width: 320px;
            height: 240px;
            top: 20px;
            right: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
        }
        
        #video-container video {
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        
        #stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
            z-index: 100;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
            max-width: 300px;
            z-index: 100;
        }
        
        .hand-point {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(0, 200, 255, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
            transition: all 0.1s;
        }
        
        .hand-line {
            position: absolute;
            background: rgba(0, 200, 255, 0.4);
            height: 2px;
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 20;
        }
        
        .palm-center {
            position: absolute;
            width: 30px;
            height: 30px;
            background: rgba(255, 50, 50, 0.6);
            border: 3px solid rgba(255, 100, 100, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 60;
        }
        
        .hand-container {
            position: absolute;
            pointer-events: none;
            z-index: 30;
        }
        
        .label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            transform: translate(-50%, -100%);
            margin-top: -5px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 70;
        }
        
        .connection {
            position: absolute;
            background: rgba(0, 200, 255, 0.3);
            height: 2px;
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 25;
        }
        
        .debug-info {
            position: fixed;
            top: 10px;
            right: 350px;
            background: rgba(0, 0, 0, 0.8);
            color: #0ff;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            z-index: 1000;
        }
        
        /* å·¦å³æ‰‹é¢œè‰²åŒºåˆ† */
        .left-hand { border-color: rgba(255, 100, 100, 0.9) !important; }
        .right-hand { border-color: rgba(100, 100, 255, 0.9) !important; }
        
        .palm-left { 
            background: rgba(255, 100, 100, 0.6) !important;
            border-color: rgba(255, 150, 150, 0.9) !important;
        }
        
        .palm-right { 
            background: rgba(100, 100, 255, 0.6) !important;
            border-color: rgba(150, 150, 255, 0.9) !important;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
    <div id="container">
        <div id="instructions">
            <h3>ğŸ® æ‰‹éƒ¨æ˜ å°„demo</h3>
            <p><strong>æŒ‰ D é”®åˆ‡æ¢è°ƒè¯•ä¿¡æ¯</strong></p>
        </div>

        <div id="video-container">
            <video id="input-video" autoplay playsinline></video>
        </div>
        
        <div id="stats">
            <div>æ£€æµ‹çŠ¶æ€: <span id="status">ç­‰å¾…æ‘„åƒå¤´...</span></div>
            <div>æ‰‹éƒ¨æ•°é‡: <span id="hand-count">0</span></div>
            <div>å·¦æ‰‹çŠ¶æ€: <span id="left-hand-status">-</span></div>
            <div>å³æ‰‹çŠ¶æ€: <span id="right-hand-status">-</span></div>
            <div>å½“å‰æ‰‹åŠ¿: <span id="current-gesture">-</span></div>
        </div>
        
        <div class="debug-info" id="debug-info"></div>
        
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let videoElement;
        let canvas;
        let ctx;
        let hands;
        let cameraUtils;
        let handElements = {};
        let debugMode = true;

        // æ‰‹éƒ¨å…³é”®ç‚¹è¿æ¥å…³ç³»
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],           // æ‹‡æŒ‡
            [0, 5], [5, 6], [6, 7], [7, 8],           // é£ŸæŒ‡
            [0, 9], [9, 10], [10, 11], [11, 12],      // ä¸­æŒ‡
            [0, 13], [13, 14], [14, 15], [15, 16],    // æ— åæŒ‡
            [0, 17], [17, 18], [18, 19], [19, 20],    // å°æŒ‡
            [5, 9], [9, 13], [13, 17]                 // æ‰‹æŒ
        ];

        const LANDMARK_NAMES = [
            'æ‰‹è…•', 'æ‹‡æŒ‡æ ¹', 'æ‹‡æŒ‡ä¸­', 'æ‹‡æŒ‡å°–',
            'é£ŸæŒ‡æ ¹', 'é£ŸæŒ‡ä¸­', 'é£ŸæŒ‡å°–',
            'ä¸­æŒ‡æ ¹', 'ä¸­æŒ‡ä¸­', 'ä¸­æŒ‡å°–',
            'æ— åæŒ‡æ ¹', 'æ— åæŒ‡ä¸­', 'æ— åæŒ‡å°–',
            'å°æŒ‡æ ¹', 'å°æŒ‡ä¸­', 'å°æŒ‡å°–'
        ];

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', init);

        function init() {
            videoElement = document.getElementById('input-video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            setupHandTracking();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function setupHandTracking() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            cameraUtils.start();
            updateStatus('æ£€æµ‹ä¸­...', '#0f0');
        }

        function onHandResults(results) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            clearHandElements();
            
            const handCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            document.getElementById('hand-count').textContent = handCount;
            
            let leftHandData = null;
            let rightHandData = null;
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const handedness = results.multiHandedness[index];
                    // å…³é”®ä¿®æ­£ï¼šMediaPipeè¿”å›çš„æ ‡ç­¾æ˜¯é•œåƒçš„ï¼Œéœ€è¦åè½¬
                    const isLeftHand = handedness.label === 'Right';  // æ‘„åƒå¤´é•œåƒåè½¬
                    const isRightHand = handedness.label === 'Left';  // æ‘„åƒå¤´é•œåƒåè½¬
                    
                    const actualHandedness = isLeftHand ? 'Left' : 'Right';
                    
                    if (isLeftHand) {
                        leftHandData = { landmarks, handedness: actualHandedness };
                    } else if (isRightHand) {
                        rightHandData = { landmarks, handedness: actualHandedness };
                    }
                    
                    drawHandToScreen(landmarks, actualHandedness, index);
                });
                
                // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                updateHandStatus(leftHandData, rightHandData);
            } else {
                updateHandStatus(null, null);
            }
            
            updateDebugInfo(results);
        }

        function drawHandToScreen(landmarks, handedness, handIndex) {
            // è®¡ç®—æ‰‹æŒä¸­å¿ƒ
            const palmPoints = [0, 5, 9, 13, 17];
            let centerX = 0, centerY = 0;
            
            palmPoints.forEach(idx => {
                centerX += landmarks[idx].x;
                centerY += landmarks[idx].y;
            });
            
            centerX /= palmPoints.length;
            centerY /= palmPoints.length;
            
            // è½¬æ¢ä¸ºå±å¹•åæ ‡
            // å…³é”®ï¼šå› ä¸ºæ‘„åƒå¤´æ˜¯é•œåƒçš„ï¼Œéœ€è¦åè½¬Xåæ ‡
            const screenCenterX = (1 - centerX) * canvas.width;  // åè½¬Xè½´
            const screenCenterY = centerY * canvas.height;
            
            // ç»˜åˆ¶æ‰‹æŒä¸­å¿ƒ
            drawPalmCenter(screenCenterX, screenCenterY, handedness, handIndex);
            
            // ç»˜åˆ¶æ‰€æœ‰å…³é”®ç‚¹
            landmarks.forEach((landmark, index) => {
                // å…³é”®ä¿®æ­£ï¼šåè½¬Xåæ ‡ä»¥åŒ¹é…å±å¹•æ˜¾ç¤º
                const screenX = (1 - landmark.x) * canvas.width;  // åè½¬Xè½´
                const screenY = landmark.y * canvas.height;
                
                drawLandmarkOnCanvas(screenX, screenY, index, handedness);
                createLandmarkElement(screenX, screenY, index, handedness, handIndex);
            });
            
            // ç»˜åˆ¶è¿æ¥çº¿ï¼ˆéœ€è¦åè½¬Xåæ ‡ï¼‰
            drawConnections(landmarks, handedness);
            
            // åˆ†ææ‰‹åŠ¿
            const gesture = analyzeGesture(landmarks, handedness);
            drawGestureLabel(screenCenterX, screenCenterY - 40, gesture, handedness);
            
            return gesture;
        }

        function drawLandmarkOnCanvas(x, y, index, handedness) {
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            
            // æ ¹æ®å·¦å³æ‰‹è®¾ç½®ä¸åŒé¢œè‰²
            if (handedness === 'Left') {
                ctx.fillStyle = index === 0 ? 'rgba(255, 150, 150, 0.8)' : 'rgba(255, 100, 100, 0.8)';
            } else {
                ctx.fillStyle = index === 0 ? 'rgba(150, 150, 255, 0.8)' : 'rgba(100, 100, 255, 0.8)';
            }
            
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ç»˜åˆ¶å…³é”®ç‚¹ç¼–å·
            if (debugMode && (index === 0 || index === 4 || index === 8 || index === 12 || index === 16 || index === 20)) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${index}`, x, y - 15);
            }
        }

        function drawConnections(landmarks, handedness) {
            HAND_CONNECTIONS.forEach(connection => {
                const [startIdx, endIdx] = connection;
                // åè½¬Xåæ ‡
                const startX = (1 - landmarks[startIdx].x) * canvas.width;
                const startY = landmarks[startIdx].y * canvas.height;
                const endX = (1 - landmarks[endIdx].x) * canvas.width;
                const endY = landmarks[endIdx].y * canvas.height;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = handedness === 'Left' ? 
                    'rgba(255, 100, 100, 0.6)' : 'rgba(100, 100, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.stroke();
            });
        }

        function drawPalmCenter(x, y, handedness, handIndex) {
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, Math.PI * 2);
            ctx.fillStyle = handedness === 'Left' ? 
                'rgba(255, 100, 100, 0.6)' : 'rgba(100, 100, 255, 0.6)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // ç»˜åˆ¶æ‰‹æŒæ ‡ç­¾
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(handedness === 'Left' ? 'å·¦æ‰‹' : 'å³æ‰‹', x, y + 30);
        }

        function createLandmarkElement(x, y, index, handedness, handIndex) {
            const pointId = `point-${handIndex}-${index}`;
            
            if (!handElements[pointId]) {
                const point = document.createElement('div');
                point.className = `hand-point ${handedness.toLowerCase()}-hand`;
                point.id = pointId;
                document.getElementById('container').appendChild(point);
                handElements[pointId] = point;
            }
            
            handElements[pointId].style.left = `${x}px`;
            handElements[pointId].style.top = `${y}px`;
            
            // ä¸ºæ‰‹è…•åˆ›å»ºæ‰‹æŒä¸­å¿ƒç‚¹
            if (index === 0) {
                const palmId = `palm-${handIndex}`;
                if (!handElements[palmId]) {
                    const palm = document.createElement('div');
                    palm.className = `palm-center palm-${handedness.toLowerCase()}`;
                    palm.id = palmId;
                    document.getElementById('container').appendChild(palm);
                    handElements[palmId] = palm;
                }
                handElements[palmId].style.left = `${x}px`;
                handElements[palmId].style.top = `${y}px`;
            }
        }

        function drawGestureLabel(x, y, gesture, handedness) {
            // ç»˜åˆ¶èƒŒæ™¯
            const text = handedness === 'Left' ? `å·¦æ‰‹: ${gesture}` : `å³æ‰‹: ${gesture}`;
            const textWidth = ctx.measureText(text).width;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(x - textWidth/2 - 10, y - 15, textWidth + 20, 30);
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = handedness === 'Left' ? 
                'rgba(255, 200, 200, 1)' : 'rgba(200, 200, 255, 1)';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x, y);
        }

        function analyzeGesture(landmarks, handedness) {
            const fingerTips = [4, 8, 12, 16, 20];
            const fingerPips = [2, 6, 10, 14, 18];
            
            let extendedCount = 0;
            
            for (let i = 0; i < 5; i++) {
                const tipY = landmarks[fingerTips[i]].y;
                const pipY = landmarks[fingerPips[i]].y;
                
                if (tipY < pipY - 0.02) {
                    extendedCount++;
                }
            }
            
            // æ‰‹åŠ¿åˆ¤æ–­
            if (extendedCount >= 4) {
                return 'æ‰‹æŒå¼ å¼€';
            } else if (extendedCount <= 1) {
                return 'æ¡æ‹³';
            } else if (extendedCount === 2) {
                // æ£€æŸ¥å‰ªåˆ€æ‰‹
                const indexExtended = landmarks[8].y < landmarks[6].y - 0.02;
                const middleExtended = landmarks[12].y < landmarks[10].y - 0.02;
                const othersNotExtended = !(landmarks[16].y < landmarks[14].y - 0.02) && 
                                         !(landmarks[20].y < landmarks[18].y - 0.02);
                
                if (indexExtended && middleExtended && othersNotExtended) {
                    return 'å‰ªåˆ€æ‰‹';
                }
                return '2æŒ‡ä¼¸å‡º';
            } else {
                return `${extendedCount}æŒ‡ä¼¸å‡º`;
            }
        }

        function updateHandStatus(leftHandData, rightHandData) {
            // æ›´æ–°å·¦æ‰‹çŠ¶æ€
            if (leftHandData) {
                const gesture = analyzeGesture(leftHandData.landmarks, 'Left');
                document.getElementById('left-hand-status').textContent = `æ£€æµ‹åˆ° - ${gesture}`;
                document.getElementById('left-hand-status').style.color = '#0f0';
            } else {
                document.getElementById('left-hand-status').textContent = 'æœªæ£€æµ‹';
                document.getElementById('left-hand-status').style.color = '#f00';
            }
            
            // æ›´æ–°å³æ‰‹çŠ¶æ€
            if (rightHandData) {
                const gesture = analyzeGesture(rightHandData.landmarks, 'Right');
                document.getElementById('right-hand-status').textContent = `æ£€æµ‹åˆ° - ${gesture}`;
                document.getElementById('right-hand-status').style.color = '#0f0';
            } else {
                document.getElementById('right-hand-status').textContent = 'æœªæ£€æµ‹';
                document.getElementById('right-hand-status').style.color = '#f00';
            }
            
            // æ›´æ–°å½“å‰æ‰‹åŠ¿
            if (leftHandData && rightHandData) {
                const leftGesture = analyzeGesture(leftHandData.landmarks, 'Left');
                const rightGesture = analyzeGesture(rightHandData.landmarks, 'Right');
                document.getElementById('current-gesture').textContent = `å·¦æ‰‹:${leftGesture} | å³æ‰‹:${rightGesture}`;
            } else if (leftHandData) {
                document.getElementById('current-gesture').textContent = 
                    `å·¦æ‰‹:${analyzeGesture(leftHandData.landmarks, 'Left')}`;
            } else if (rightHandData) {
                document.getElementById('current-gesture').textContent = 
                    `å³æ‰‹:${analyzeGesture(rightHandData.landmarks, 'Right')}`;
            } else {
                document.getElementById('current-gesture').textContent = '-';
            }
        }

        function updateDebugInfo(results) {
            if (!debugMode) return;
            
            let debugText = 'MediaPipe æ‰‹éƒ¨æ£€æµ‹ä¿¡æ¯:\n\n';
            debugText += `å±å¹•å°ºå¯¸: ${canvas.width} x ${canvas.height}\n`;
            debugText += `æ‘„åƒå¤´: 320 x 240 (é•œåƒ)\n\n`;
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                debugText += `æ£€æµ‹åˆ° ${results.multiHandLandmarks.length} åªæ‰‹:\n`;
                
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const handedness = results.multiHandedness[index];
                    // æ˜¾ç¤ºMediaPipeåŸå§‹æ ‡ç­¾å’Œå®é™…æ ‡ç­¾
                    const actualHandedness = handedness.label === 'Right' ? 'Left' : 'Right';
                    
                    debugText += `\næ‰‹ ${index + 1}:\n`;
                    debugText += `  MediaPipeæ ‡ç­¾: ${handedness.label}\n`;
                    debugText += `  å®é™…æ˜¯: ${actualHandedness}\n`;
                    debugText += `  ç½®ä¿¡åº¦: ${handedness.score.toFixed(3)}\n`;
                    
                    // æ˜¾ç¤ºå‡ ä¸ªå…³é”®ç‚¹
                    const keyPoints = [0, 8, 12, 16, 20];
                    keyPoints.forEach(pointIdx => {
                        const point = landmarks[pointIdx];
                        debugText += `  ç‚¹ ${pointIdx}: `;
                        debugText += `åŸå§‹(x=${point.x.toFixed(3)}, y=${point.y.toFixed(3)}) `;
                        debugText += `å±å¹•(x=${((1-point.x)*canvas.width).toFixed(0)}, y=${(point.y*canvas.height).toFixed(0)})\n`;
                    });
                });
            } else {
                debugText += 'æœªæ£€æµ‹åˆ°æ‰‹éƒ¨';
            }
            
            document.getElementById('debug-info').textContent = debugText;
        }

        function clearHandElements() {
            Object.keys(handElements).forEach(id => {
                if (handElements[id] && handElements[id].parentNode) {
                    handElements[id].parentNode.removeChild(handElements[id]);
                }
            });
            handElements = {};
        }

        function updateStatus(text, color) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = text;
            statusEl.style.color = color;
        }

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (e.key === 'd' || e.key === 'D') {
                debugMode = !debugMode;
                document.getElementById('debug-info').style.display = 
                    debugMode ? 'block' : 'none';
            }
            if (e.key === 'r' || e.key === 'R') {
                // é‡æ–°å¼€å§‹
                clearHandElements();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                updateStatus('é‡æ–°æ£€æµ‹ä¸­...', '#ff0');
            }
        });
    </script>
</body>
</html>