<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ‰‹éƒ¨è¿½è¸ªæ¼”ç¤º</title>
    <link rel="icon" type="image/x-icon" href="../assets/images/favicon.ico">
    
    <!-- CSS -->
    <link rel="stylesheet" href="../assets/css/reset.css">
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/animations.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video-container {
            position: absolute;
            width: 320px;
            height: 240px;
            top: 20px;
            right: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
        }
        
        #video-container video {
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        
        #gesture-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            pointer-events: none;
        }
        
        #stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
            z-index: 100;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
            max-width: 300px;
            z-index: 100;
        }
        
        #toolbar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        .toolbar-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .toolbar-btn:hover {
            transform: scale(1.05);
        }
        
        .btn-screenshot {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-json {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .btn-csv {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .btn-screenshot:hover {
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
        }
        
        .btn-json:hover {
            box-shadow: 0 4px 15px rgba(240, 147, 251, 0.5);
        }
        
        .btn-csv:hover {
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.5);
        }
        
        .hand-point {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(0, 200, 255, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
            transition: all 0.1s;
        }
        
        .hand-line {
            position: absolute;
            background: rgba(0, 200, 255, 0.4);
            height: 2px;
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 20;
        }
        
        .palm-center {
            position: absolute;
            width: 30px;
            height: 30px;
            background: rgba(255, 50, 50, 0.6);
            border: 3px solid rgba(255, 100, 100, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 60;
        }
        
        .hand-container {
            position: absolute;
            pointer-events: none;
            z-index: 30;
        }
        
        .label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            transform: translate(-50%, -100%);
            margin-top: -5px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 70;
        }
        
        .connection {
            position: absolute;
            background: rgba(0, 200, 255, 0.3);
            height: 2px;
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 25;
        }
        
        .debug-info {
            position: fixed;
            top: 10px;
            right: 350px;
            background: rgba(0, 0, 0, 0.8);
            color: #0ff;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            z-index: 1000;
        }
        
        /* å·¦å³æ‰‹é¢œè‰²åŒºåˆ† */
        .left-hand { border-color: rgba(255, 100, 100, 0.9) !important; }
        .right-hand { border-color: rgba(100, 100, 255, 0.9) !important; }
        
        .palm-left { 
            background: rgba(255, 100, 100, 0.6) !important;
            border-color: rgba(255, 150, 150, 0.9) !important;
        }
        
        .palm-right { 
            background: rgba(100, 100, 255, 0.6) !important;
            border-color: rgba(150, 150, 255, 0.9) !important;
        }
        
        /* é€šçŸ¥æ ·å¼ */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 2000;
            animation: fadeInOut 2s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        /* æ‰‹åŠ¿ç‰¹æ•ˆæ ·å¼ */
        .gesture-effect {
            position: absolute;
            pointer-events: none;
            z-index: 200;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
    <a href="../index.html" class="logo">
        <img src="../assets/images/favicon.ico" alt="favicon" class="nav-favicon">
        <span class="artistic-text">
            <span class="letter">E</span>
            <span class="letter">d</span>
            <span class="letter">d</span>
            <span class="letter">i</span>
            <span class="letter">e</span>
        </span>
    </a>
    <div id="container">
        <div id="instructions">
            <h3>ğŸ® æ‰‹éƒ¨æ˜ å°„demo</h3>
            <p><strong>æŒ‰ D é”®åˆ‡æ¢è°ƒè¯•ä¿¡æ¯</strong></p>
            <p><strong>æŒ‰ R é”®é‡ç½®</strong></p>
        </div>

        <div id="video-container">
            <video id="input-video" autoplay playsinline></video>
        </div>
        
        <div id="stats">
            <div>æ£€æµ‹çŠ¶æ€: <span id="status">ç­‰å¾…æ‘„åƒå¤´...</span></div>
            <div>æ‰‹éƒ¨æ•°é‡: <span id="hand-count">0</span></div>
            <div>å·¦æ‰‹çŠ¶æ€: <span id="left-hand-status">-</span></div>
            <div>å³æ‰‹çŠ¶æ€: <span id="right-hand-status">-</span></div>
            <div>å½“å‰æ‰‹åŠ¿: <span id="current-gesture">-</span></div>
        </div>
        
        <div id="toolbar">
            <button class="toolbar-btn btn-screenshot" onclick="captureScreenshot()">
                ğŸ“· æˆªå›¾ä¿å­˜
            </button>
            <button class="toolbar-btn btn-json" onclick="exportJSON()">
                ğŸ“„ å¯¼å‡ºå…³é”®ç‚¹æ•°æ® (JSON)
            </button>
            <button class="toolbar-btn btn-csv" onclick="exportCSV()">
                ğŸ“Š å¯¼å‡ºå…³é”®ç‚¹æ•°æ® (CSV)
            </button>
        </div>
        
        <div class="debug-info" id="debug-info"></div>
        
        <canvas id="canvas"></canvas>
        <canvas id="gesture-canvas"></canvas>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let videoElement;
        let canvas;
        let ctx;
        let gestureCanvas;
        let gestureCtx;
        let hands;
        let cameraUtils;
        let handElements = {};
        let debugMode = true;
        let currentHandData = null; // å­˜å‚¨å½“å‰å¸§çš„æ‰‹éƒ¨æ•°æ®
        let gestureEffects = []; // å­˜å‚¨æ‰‹åŠ¿ç‰¹æ•ˆ

        // æ‰‹éƒ¨å…³é”®ç‚¹è¿æ¥å…³ç³»
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],           // æ‹‡æŒ‡
            [0, 5], [5, 6], [6, 7], [7, 8],           // é£ŸæŒ‡
            [0, 9], [9, 10], [10, 11], [11, 12],      // ä¸­æŒ‡
            [0, 13], [13, 14], [14, 15], [15, 16],    // æ— åæŒ‡
            [0, 17], [17, 18], [18, 19], [19, 20],    // å°æŒ‡
            [5, 9], [9, 13], [13, 17]                 // æ‰‹æŒ
        ];

        const LANDMARK_NAMES = [
            'WRIST', 'THUMB_CMC', 'THUMB_MCP', 'THUMB_IP', 'THUMB_TIP',
            'INDEX_FINGER_MCP', 'INDEX_FINGER_PIP', 'INDEX_FINGER_DIP', 'INDEX_FINGER_TIP',
            'MIDDLE_FINGER_MCP', 'MIDDLE_FINGER_PIP', 'MIDDLE_FINGER_DIP', 'MIDDLE_FINGER_TIP',
            'RING_FINGER_MCP', 'RING_FINGER_PIP', 'RING_FINGER_DIP', 'RING_FINGER_TIP',
            'PINKY_MCP', 'PINKY_PIP', 'PINKY_DIP', 'PINKY_TIP'
        ];

        const LANDMARK_NAMES_CN = [
            'æ‰‹è…•', 'æ‹‡æŒ‡è…•æŒå…³èŠ‚', 'æ‹‡æŒ‡æŒæŒ‡å…³èŠ‚', 'æ‹‡æŒ‡æŒ‡é—´å…³èŠ‚', 'æ‹‡æŒ‡å°–',
            'é£ŸæŒ‡æŒæŒ‡å…³èŠ‚', 'é£ŸæŒ‡è¿‘ç«¯æŒ‡é—´å…³èŠ‚', 'é£ŸæŒ‡è¿œç«¯æŒ‡é—´å…³èŠ‚', 'é£ŸæŒ‡å°–',
            'ä¸­æŒ‡æŒæŒ‡å…³èŠ‚', 'ä¸­æŒ‡è¿‘ç«¯æŒ‡é—´å…³èŠ‚', 'ä¸­æŒ‡è¿œç«¯æŒ‡é—´å…³èŠ‚', 'ä¸­æŒ‡å°–',
            'æ— åæŒ‡æŒæŒ‡å…³èŠ‚', 'æ— åæŒ‡è¿‘ç«¯æŒ‡é—´å…³èŠ‚', 'æ— åæŒ‡è¿œç«¯æŒ‡é—´å…³èŠ‚', 'æ— åæŒ‡å°–',
            'å°æŒ‡æŒæŒ‡å…³èŠ‚', 'å°æŒ‡è¿‘ç«¯æŒ‡é—´å…³èŠ‚', 'å°æŒ‡è¿œç«¯æŒ‡é—´å…³èŠ‚', 'å°æŒ‡å°–'
        ];

        // æ‰‹åŠ¿å›¾æ ‡å’Œé¢œè‰²é…ç½®
        const GESTURE_CONFIG = {
            'æ‰‹æŒå¼ å¼€': { icon: 'âœ‹', color: '#00ff88', particles: true, glow: true },
            'æ¡æ‹³': { icon: 'âœŠ', color: '#ff4444', particles: false, glow: true },
            'å‰ªåˆ€æ‰‹': { icon: 'âœŒï¸', color: '#ffff00', particles: true, glow: true },
            'ç«–å¤§æ‹‡æŒ‡': { icon: 'ğŸ‘', color: '#00aaff', particles: true, glow: true },
            'æŒ‡å‘': { icon: 'ğŸ‘†', color: '#ff88ff', particles: false, glow: true },
            '2æŒ‡ä¼¸å‡º': { icon: '2ï¸âƒ£', color: '#88ffff', particles: false, glow: false },
            '3æŒ‡ä¼¸å‡º': { icon: '3ï¸âƒ£', color: '#88ff88', particles: false, glow: false },
            '4æŒ‡ä¼¸å‡º': { icon: '4ï¸âƒ£', color: '#ffaa88', particles: false, glow: false },
            'OKæ‰‹åŠ¿': { icon: 'ğŸ‘Œ', color: '#ff00ff', particles: true, glow: true },
            'æ‘‡æ»š': { icon: 'ğŸ¤˜', color: '#ff6600', particles: true, glow: true }
        };

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', init);

        function init() {
            videoElement = document.getElementById('input-video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            gestureCanvas = document.getElementById('gesture-canvas');
            gestureCtx = gestureCanvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            setupHandTracking();
            
            // å¯åŠ¨ç‰¹æ•ˆåŠ¨ç”»å¾ªç¯
            requestAnimationFrame(animateGestureEffects);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gestureCanvas.width = window.innerWidth;
            gestureCanvas.height = window.innerHeight;
        }

        function setupHandTracking() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            cameraUtils.start();
            updateStatus('æ£€æµ‹ä¸­...', '#0f0');
        }

        function onHandResults(results) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            clearHandElements();
            
            const handCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            document.getElementById('hand-count').textContent = handCount;
            
            let leftHandData = null;
            let rightHandData = null;
            
            // å­˜å‚¨å½“å‰å¸§æ•°æ®ç”¨äºå¯¼å‡º
            currentHandData = {
                timestamp: new Date().toISOString(),
                screenWidth: canvas.width,
                screenHeight: canvas.height,
                hands: []
            };
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const handedness = results.multiHandedness[index];
                    // å…³é”®ä¿®æ­£ï¼šMediaPipeè¿”å›çš„æ ‡ç­¾æ˜¯é•œåƒçš„ï¼Œéœ€è¦åè½¬
                    const isLeftHand = handedness.label === 'Right';  // æ‘„åƒå¤´é•œåƒåè½¬
                    const isRightHand = handedness.label === 'Left';  // æ‘„åƒå¤´é•œåƒåè½¬
                    
                    const actualHandedness = isLeftHand ? 'Left' : 'Right';
                    
                    // å­˜å‚¨æ‰‹éƒ¨æ•°æ®
                    const handInfo = {
                        handedness: actualHandedness,
                        confidence: handedness.score,
                        landmarks: landmarks.map((lm, i) => ({
                            index: i,
                            name: LANDMARK_NAMES[i],
                            nameCN: LANDMARK_NAMES_CN[i],
                            x: lm.x,
                            y: lm.y,
                            z: lm.z,
                            screenX: (1 - lm.x) * canvas.width,
                            screenY: lm.y * canvas.height
                        }))
                    };
                    
                    if (isLeftHand) {
                        leftHandData = { landmarks, handedness: actualHandedness };
                        handInfo.gesture = analyzeGesture(landmarks, 'Left');
                    } else if (isRightHand) {
                        rightHandData = { landmarks, handedness: actualHandedness };
                        handInfo.gesture = analyzeGesture(landmarks, 'Right');
                    }
                    
                    currentHandData.hands.push(handInfo);
                    
                    drawHandToScreen(landmarks, actualHandedness, index);
                });
                
                // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                updateHandStatus(leftHandData, rightHandData);
            } else {
                updateHandStatus(null, null);
            }
            
            updateDebugInfo(results);
        }

        function drawHandToScreen(landmarks, handedness, handIndex) {
            // è®¡ç®—æ‰‹æŒä¸­å¿ƒ
            const palmPoints = [0, 5, 9, 13, 17];
            let centerX = 0, centerY = 0;
            
            palmPoints.forEach(idx => {
                centerX += landmarks[idx].x;
                centerY += landmarks[idx].y;
            });
            
            centerX /= palmPoints.length;
            centerY /= palmPoints.length;
            
            // è½¬æ¢ä¸ºå±å¹•åæ ‡
            // å…³é”®ï¼šå› ä¸ºæ‘„åƒå¤´æ˜¯é•œåƒçš„ï¼Œéœ€è¦åè½¬Xåæ ‡
            const screenCenterX = (1 - centerX) * canvas.width;  // åè½¬Xè½´
            const screenCenterY = centerY * canvas.height;
            
            // ç»˜åˆ¶æ‰‹æŒä¸­å¿ƒ
            drawPalmCenter(screenCenterX, screenCenterY, handedness, handIndex);
            
            // ç»˜åˆ¶æ‰€æœ‰å…³é”®ç‚¹
            landmarks.forEach((landmark, index) => {
                // å…³é”®ä¿®æ­£ï¼šåè½¬Xåæ ‡ä»¥åŒ¹é…å±å¹•æ˜¾ç¤º
                const screenX = (1 - landmark.x) * canvas.width;  // åè½¬Xè½´
                const screenY = landmark.y * canvas.height;
                
                drawLandmarkOnCanvas(screenX, screenY, index, handedness);
                createLandmarkElement(screenX, screenY, index, handedness, handIndex);
            });
            
            // ç»˜åˆ¶è¿æ¥çº¿ï¼ˆéœ€è¦åè½¬Xåæ ‡ï¼‰
            drawConnections(landmarks, handedness);
            
            // åˆ†ææ‰‹åŠ¿
            const gesture = analyzeGesture(landmarks, handedness);
            
            // ä½¿ç”¨å¢å¼ºçš„æ‰‹åŠ¿æ¸²æŸ“
            renderGestureEnhanced(screenCenterX, screenCenterY, gesture, handedness, landmarks);
            
            return gesture;
        }

        function drawLandmarkOnCanvas(x, y, index, handedness) {
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            
            // æ ¹æ®å·¦å³æ‰‹è®¾ç½®ä¸åŒé¢œè‰²
            if (handedness === 'Left') {
                ctx.fillStyle = index === 0 ? 'rgba(255, 150, 150, 0.8)' : 'rgba(255, 100, 100, 0.8)';
            } else {
                ctx.fillStyle = index === 0 ? 'rgba(150, 150, 255, 0.8)' : 'rgba(100, 100, 255, 0.8)';
            }
            
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ç»˜åˆ¶å…³é”®ç‚¹ç¼–å·
            if (debugMode && (index === 0 || index === 4 || index === 8 || index === 12 || index === 16 || index === 20)) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${index}`, x, y - 15);
            }
        }

        function drawConnections(landmarks, handedness) {
            HAND_CONNECTIONS.forEach(connection => {
                const [startIdx, endIdx] = connection;
                // åè½¬Xåæ ‡
                const startX = (1 - landmarks[startIdx].x) * canvas.width;
                const startY = landmarks[startIdx].y * canvas.height;
                const endX = (1 - landmarks[endIdx].x) * canvas.width;
                const endY = landmarks[endIdx].y * canvas.height;
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = handedness === 'Left' ? 
                    'rgba(255, 100, 100, 0.6)' : 'rgba(100, 100, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.stroke();
            });
        }

        function drawPalmCenter(x, y, handedness, handIndex) {
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, Math.PI * 2);
            ctx.fillStyle = handedness === 'Left' ? 
                'rgba(255, 100, 100, 0.6)' : 'rgba(100, 100, 255, 0.6)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // ç»˜åˆ¶æ‰‹æŒæ ‡ç­¾
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(handedness === 'Left' ? 'å·¦æ‰‹' : 'å³æ‰‹', x, y + 30);
        }

        function createLandmarkElement(x, y, index, handedness, handIndex) {
            const pointId = `point-${handIndex}-${index}`;
            
            if (!handElements[pointId]) {
                const point = document.createElement('div');
                point.className = `hand-point ${handedness.toLowerCase()}-hand`;
                point.id = pointId;
                document.getElementById('container').appendChild(point);
                handElements[pointId] = point;
            }
            
            handElements[pointId].style.left = `${x}px`;
            handElements[pointId].style.top = `${y}px`;
            
            // ä¸ºæ‰‹è…•åˆ›å»ºæ‰‹æŒä¸­å¿ƒç‚¹
            if (index === 0) {
                const palmId = `palm-${handIndex}`;
                if (!handElements[palmId]) {
                    const palm = document.createElement('div');
                    palm.className = `palm-center palm-${handedness.toLowerCase()}`;
                    palm.id = palmId;
                    document.getElementById('container').appendChild(palm);
                    handElements[palmId] = palm;
                }
                handElements[palmId].style.left = `${x}px`;
                handElements[palmId].style.top = `${y}px`;
            }
        }

        // å¢å¼ºçš„æ‰‹åŠ¿æ¸²æŸ“æ–¹æ³•
        function renderGestureEnhanced(x, y, gesture, handedness, landmarks) {
            const config = GESTURE_CONFIG[gesture] || { icon: 'ğŸ–ï¸', color: '#ffffff', particles: false, glow: false };
            
            // ç»˜åˆ¶å‘å…‰æ•ˆæœ
            if (config.glow) {
                drawGlowEffect(x, y - 60, config.color);
            }
            
            // ç»˜åˆ¶æ‰‹åŠ¿å›¾æ ‡å’Œæ–‡å­—
            drawGestureIconAndText(x, y - 60, gesture, config, handedness);
            
            // æ·»åŠ ç²’å­æ•ˆæœ
            if (config.particles) {
                addParticleEffect(x, y - 60, config.color);
            }
            
            // ç‰¹æ®Šæ‰‹åŠ¿çš„é¢å¤–æ•ˆæœ
            renderSpecialGestureEffects(gesture, landmarks, handedness, config.color);
        }

        function drawGlowEffect(x, y, color) {
            ctx.save();
            ctx.shadowBlur = 30;
            ctx.shadowColor = color;
            ctx.beginPath();
            ctx.arc(x, y, 40, 0, Math.PI * 2);
            ctx.fillStyle = color + '33'; // æ·»åŠ é€æ˜åº¦
            ctx.fill();
            ctx.restore();
        }

        function drawGestureIconAndText(x, y, gesture, config, handedness) {
            // ç»˜åˆ¶èƒŒæ™¯
            const text = handedness === 'Left' ? `å·¦æ‰‹: ${gesture}` : `å³æ‰‹: ${gesture}`;
            ctx.font = 'bold 16px Arial';
            const textWidth = ctx.measureText(text).width;
            
            // æ¸å˜èƒŒæ™¯
            const gradient = ctx.createLinearGradient(x - textWidth/2 - 30, y - 20, x + textWidth/2 + 30, y + 20);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(30, 30, 30, 0.9)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.roundRect(x - textWidth/2 - 35, y - 25, textWidth + 70, 50, 10);
            ctx.fill();
            
            // ç»˜åˆ¶è¾¹æ¡†
            ctx.strokeStyle = config.color;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ç»˜åˆ¶å›¾æ ‡
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(config.icon, x - textWidth/2 - 15, y);
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = config.color;
            ctx.fillText(text, x + 15, y);
        }

        function addParticleEffect(x, y, color) {
            // æ·»åŠ ç²’å­åˆ°æ•ˆæœæ•°ç»„
            for (let i = 0; i < 3; i++) {
                gestureEffects.push({
                    type: 'particle',
                    x: x + (Math.random() - 0.5) * 60,
                    y: y + (Math.random() - 0.5) * 40,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 3 - 1,
                    size: Math.random() * 6 + 2,
                    color: color,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02
                });
            }
        }

        function renderSpecialGestureEffects(gesture, landmarks, handedness, color) {
            // åè½¬Xåæ ‡çš„è¾…åŠ©å‡½æ•°
            const getScreenX = (lm) => (1 - lm.x) * canvas.width;
            const getScreenY = (lm) => lm.y * canvas.height;
            
            switch(gesture) {
                case 'æŒ‡å‘':
                    // ç»˜åˆ¶æŒ‡å‘å°„çº¿
                    const indexTip = landmarks[8];
                    const indexPip = landmarks[6];
                    const dirX = getScreenX(indexTip) - getScreenX(indexPip);
                    const dirY = getScreenY(indexTip) - getScreenY(indexPip);
                    const length = Math.sqrt(dirX * dirX + dirY * dirY);
                    const normX = dirX / length;
                    const normY = dirY / length;
                    
                    ctx.save();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.moveTo(getScreenX(indexTip), getScreenY(indexTip));
                    ctx.lineTo(
                        getScreenX(indexTip) + normX * 200,
                        getScreenY(indexTip) + normY * 200
                    );
                    ctx.stroke();
                    ctx.restore();
                    break;
                    
                case 'å‰ªåˆ€æ‰‹':
                    // ç»˜åˆ¶Vå­—å…‰æ•ˆ
                    const index8 = landmarks[8];
                    const middle12 = landmarks[12];
                    
                    ctx.save();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = color;
                    ctx.beginPath();
                    ctx.moveTo(getScreenX(index8), getScreenY(index8));
                    ctx.lineTo(getScreenX(index8) - 20, getScreenY(index8) - 40);
                    ctx.moveTo(getScreenX(middle12), getScreenY(middle12));
                    ctx.lineTo(getScreenX(middle12) + 20, getScreenY(middle12) - 40);
                    ctx.stroke();
                    ctx.restore();
                    break;
                    
                case 'ç«–å¤§æ‹‡æŒ‡':
                    // ç»˜åˆ¶å…‰èŠ’æ•ˆæœ
                    const thumbTip = landmarks[4];
                    const tx = getScreenX(thumbTip);
                    const ty = getScreenY(thumbTip);
                    
                    ctx.save();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(tx + Math.cos(angle) * 15, ty + Math.sin(angle) * 15);
                        ctx.lineTo(tx + Math.cos(angle) * 30, ty + Math.sin(angle) * 30);
                        ctx.stroke();
                    }
                    ctx.restore();
                    break;
                    
                case 'OKæ‰‹åŠ¿':
                    // ç»˜åˆ¶åœ†ç¯æ•ˆæœ
                    const thumb4 = landmarks[4];
                    const index8ok = landmarks[8];
                    const okX = (getScreenX(thumb4) + getScreenX(index8ok)) / 2;
                    const okY = (getScreenY(thumb4) + getScreenY(index8ok)) / 2;
                    
                    ctx.save();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                    ctx.beginPath();
                    ctx.arc(okX, okY, 25, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                    break;
                    
                case 'æ‘‡æ»š':
                    // ç»˜åˆ¶é—ªç”µæ•ˆæœ
                    const rockIndex = landmarks[8];
                    const rockPinky = landmarks[20];
                    
                    ctx.save();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = color;
                    
                    // é—ªç”µåœ¨é£ŸæŒ‡ä¸Šæ–¹
                    drawLightning(getScreenX(rockIndex), getScreenY(rockIndex) - 50, 30);
                    // é—ªç”µåœ¨å°æŒ‡ä¸Šæ–¹
                    drawLightning(getScreenX(rockPinky), getScreenY(rockPinky) - 50, 30);
                    
                    ctx.restore();
                    break;
            }
        }

        function drawLightning(x, y, size) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - size * 0.3, y + size * 0.4);
            ctx.lineTo(x + size * 0.1, y + size * 0.4);
            ctx.lineTo(x - size * 0.2, y + size);
            ctx.lineTo(x + size * 0.2, y + size * 0.5);
            ctx.lineTo(x - size * 0.1, y + size * 0.5);
            ctx.lineTo(x + size * 0.3, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function animateGestureEffects() {
            gestureCtx.clearRect(0, 0, gestureCanvas.width, gestureCanvas.height);
            
            // æ›´æ–°å’Œç»˜åˆ¶ç²’å­
            gestureEffects = gestureEffects.filter(effect => {
                if (effect.type === 'particle') {
                    effect.x += effect.vx;
                    effect.y += effect.vy;
                    effect.life -= effect.decay;
                    
                    if (effect.life > 0) {
                        gestureCtx.save();
                        gestureCtx.globalAlpha = effect.life;
                        gestureCtx.fillStyle = effect.color;
                        gestureCtx.beginPath();
                        gestureCtx.arc(effect.x, effect.y, effect.size * effect.life, 0, Math.PI * 2);
                        gestureCtx.fill();
                        gestureCtx.restore();
                        return true;
                    }
                }
                return false;
            });
            
            requestAnimationFrame(animateGestureEffects);
        }

        function analyzeGesture(landmarks, handedness) {
            const fingerTips = [4, 8, 12, 16, 20];
            const fingerPips = [2, 6, 10, 14, 18];
            const fingerMcps = [1, 5, 9, 13, 17];
            
            let extendedFingers = [];
            
            // æ£€æŸ¥æ¯ä¸ªæ‰‹æŒ‡æ˜¯å¦ä¼¸å±•
            for (let i = 0; i < 5; i++) {
                const tipY = landmarks[fingerTips[i]].y;
                const pipY = landmarks[fingerPips[i]].y;
                const mcpY = landmarks[fingerMcps[i]].y;
                
                if (i === 0) {
                    // æ‹‡æŒ‡ç‰¹æ®Šå¤„ç†ï¼šæ£€æŸ¥æ˜¯å¦å‘å¤–ä¼¸å±•
                    const thumbTip = landmarks[4];
                    const thumbMcp = landmarks[2];
                    const indexMcp = landmarks[5];
                    
                    // è®¡ç®—æ‹‡æŒ‡æ˜¯å¦ä¼¸å±•ï¼ˆç›¸å¯¹äºé£ŸæŒ‡æ ¹éƒ¨çš„ä½ç½®ï¼‰
                    const thumbExtended = Math.abs(thumbTip.x - indexMcp.x) > 0.1;
                    extendedFingers.push(thumbExtended);
                } else {
                    extendedFingers.push(tipY < pipY - 0.02);
                }
            }
            
            const extendedCount = extendedFingers.filter(e => e).length;
            
            // æ£€æŸ¥OKæ‰‹åŠ¿ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡å½¢æˆåœ†åœˆï¼‰
            const thumb4 = landmarks[4];
            const index8 = landmarks[8];
            const distance = Math.sqrt(
                Math.pow(thumb4.x - index8.x, 2) + 
                Math.pow(thumb4.y - index8.y, 2)
            );
            if (distance < 0.05 && extendedFingers[2] && extendedFingers[3] && extendedFingers[4]) {
                return 'OKæ‰‹åŠ¿';
            }
            
            // æ£€æŸ¥æ‘‡æ»šæ‰‹åŠ¿ï¼ˆé£ŸæŒ‡å’Œå°æŒ‡ä¼¸å±•ï¼Œä¸­æŒ‡å’Œæ— åæŒ‡å¼¯æ›²ï¼‰
            if (extendedFingers[1] && !extendedFingers[2] && !extendedFingers[3] && extendedFingers[4]) {
                return 'æ‘‡æ»š';
            }
            
            // æ£€æŸ¥ç«–å¤§æ‹‡æŒ‡ï¼ˆåªæœ‰æ‹‡æŒ‡ä¼¸å±•ä¸”å‘ä¸Šï¼‰
            if (extendedFingers[0] && !extendedFingers[1] && !extendedFingers[2] && 
                !extendedFingers[3] && !extendedFingers[4]) {
                const thumbTip = landmarks[4];
                const wrist = landmarks[0];
                if (thumbTip.y < wrist.y - 0.1) {
                    return 'ç«–å¤§æ‹‡æŒ‡';
                }
            }
            
            // æ£€æŸ¥æŒ‡å‘ï¼ˆåªæœ‰é£ŸæŒ‡ä¼¸å±•ï¼‰
            if (!extendedFingers[0] && extendedFingers[1] && !extendedFingers[2] && 
                !extendedFingers[3] && !extendedFingers[4]) {
                return 'æŒ‡å‘';
            }
            
            // æ‰‹åŠ¿åˆ¤æ–­
            if (extendedCount >= 4) {
                return 'æ‰‹æŒå¼ å¼€';
            } else if (extendedCount <= 1 && !extendedFingers[0]) {
                return 'æ¡æ‹³';
            } else if (extendedCount === 2) {
                // æ£€æŸ¥å‰ªåˆ€æ‰‹
                if (extendedFingers[1] && extendedFingers[2] && 
                    !extendedFingers[3] && !extendedFingers[4]) {
                    return 'å‰ªåˆ€æ‰‹';
                }
                return '2æŒ‡ä¼¸å‡º';
            } else {
                return `${extendedCount}æŒ‡ä¼¸å‡º`;
            }
        }

        function updateHandStatus(leftHandData, rightHandData) {
            // æ›´æ–°å·¦æ‰‹çŠ¶æ€
            if (leftHandData) {
                const gesture = analyzeGesture(leftHandData.landmarks, 'Left');
                document.getElementById('left-hand-status').textContent = `æ£€æµ‹åˆ° - ${gesture}`;
                document.getElementById('left-hand-status').style.color = '#0f0';
            } else {
                document.getElementById('left-hand-status').textContent = 'æœªæ£€æµ‹';
                document.getElementById('left-hand-status').style.color = '#f00';
            }
            
            // æ›´æ–°å³æ‰‹çŠ¶æ€
            if (rightHandData) {
                const gesture = analyzeGesture(rightHandData.landmarks, 'Right');
                document.getElementById('right-hand-status').textContent = `æ£€æµ‹åˆ° - ${gesture}`;
                document.getElementById('right-hand-status').style.color = '#0f0';
            } else {
                document.getElementById('right-hand-status').textContent = 'æœªæ£€æµ‹';
                document.getElementById('right-hand-status').style.color = '#f00';
            }
            
            // æ›´æ–°å½“å‰æ‰‹åŠ¿
            if (leftHandData && rightHandData) {
                const leftGesture = analyzeGesture(leftHandData.landmarks, 'Left');
                const rightGesture = analyzeGesture(rightHandData.landmarks, 'Right');
                document.getElementById('current-gesture').textContent = `å·¦æ‰‹:${leftGesture} | å³æ‰‹:${rightGesture}`;
            } else if (leftHandData) {
                document.getElementById('current-gesture').textContent = 
                    `å·¦æ‰‹:${analyzeGesture(leftHandData.landmarks, 'Left')}`;
            } else if (rightHandData) {
                document.getElementById('current-gesture').textContent = 
                    `å³æ‰‹:${analyzeGesture(rightHandData.landmarks, 'Right')}`;
            } else {
                document.getElementById('current-gesture').textContent = '-';
            }
        }

        function updateDebugInfo(results) {
            if (!debugMode) return;
            
            let debugText = 'MediaPipe æ‰‹éƒ¨æ£€æµ‹ä¿¡æ¯:\n\n';
            debugText += `å±å¹•å°ºå¯¸: ${canvas.width} x ${canvas.height}\n`;
            debugText += `æ‘„åƒå¤´: 320 x 240 (é•œåƒ)\n\n`;
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                debugText += `æ£€æµ‹åˆ° ${results.multiHandLandmarks.length} åªæ‰‹:\n`;
                
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const handedness = results.multiHandedness[index];
                    // æ˜¾ç¤ºMediaPipeåŸå§‹æ ‡ç­¾å’Œå®é™…æ ‡ç­¾
                    const actualHandedness = handedness.label === 'Right' ? 'Left' : 'Right';
                    
                    debugText += `\næ‰‹ ${index + 1}:\n`;
                    debugText += `  MediaPipeæ ‡ç­¾: ${handedness.label}\n`;
                    debugText += `  å®é™…æ˜¯: ${actualHandedness}\n`;
                    debugText += `  ç½®ä¿¡åº¦: ${handedness.score.toFixed(3)}\n`;
                    
                    // æ˜¾ç¤ºå‡ ä¸ªå…³é”®ç‚¹
                    const keyPoints = [0, 8, 12, 16, 20];
                    keyPoints.forEach(pointIdx => {
                        const point = landmarks[pointIdx];
                        debugText += `  ç‚¹ ${pointIdx}: `;
                        debugText += `åŸå§‹(x=${point.x.toFixed(3)}, y=${point.y.toFixed(3)}) `;
                        debugText += `å±å¹•(x=${((1-point.x)*canvas.width).toFixed(0)}, y=${(point.y*canvas.height).toFixed(0)})\n`;
                    });
                });
            } else {
                debugText += 'æœªæ£€æµ‹åˆ°æ‰‹éƒ¨';
            }
            
            document.getElementById('debug-info').textContent = debugText;
        }

        function clearHandElements() {
            Object.keys(handElements).forEach(id => {
                if (handElements[id] && handElements[id].parentNode) {
                    handElements[id].parentNode.removeChild(handElements[id]);
                }
            });
            handElements = {};
        }

        function updateStatus(text, color) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = text;
            statusEl.style.color = color;
        }

        // ============ å¯¼å‡ºåŠŸèƒ½ ============

        // æˆªå›¾ä¿å­˜
        function captureScreenshot() {
            // åˆ›å»ºä¸€ä¸ªæ–°çš„canvasæ¥åˆå¹¶æ‰€æœ‰å›¾å±‚
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');
            
            // ç»˜åˆ¶é»‘è‰²èƒŒæ™¯
            exportCtx.fillStyle = '#000';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // ç»˜åˆ¶ä¸»ç”»å¸ƒå†…å®¹
            exportCtx.drawImage(canvas, 0, 0);
            
            // ç»˜åˆ¶æ‰‹åŠ¿ç‰¹æ•ˆç”»å¸ƒ
            exportCtx.drawImage(gestureCanvas, 0, 0);
            
            // æ·»åŠ æ—¶é—´æˆ³æ°´å°
            const timestamp = new Date().toLocaleString('zh-CN');
            exportCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            exportCtx.font = '14px Arial';
            exportCtx.textAlign = 'right';
            exportCtx.fillText(`æˆªå›¾æ—¶é—´: ${timestamp}`, exportCanvas.width - 20, exportCanvas.height - 20);
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const link = document.createElement('a');
            const filename = `hand_tracking_${Date.now()}.png`;
            link.download = filename;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
            
            showNotification(`ğŸ“· æˆªå›¾å·²ä¿å­˜: ${filename}`);
        }

        // å¯¼å‡ºJSON
        function exportJSON() {
            if (!currentHandData || currentHandData.hands.length === 0) {
                showNotification('âš ï¸ å½“å‰æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹éƒ¨æ•°æ®');
                return;
            }
            
            const jsonStr = JSON.stringify(currentHandData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const link = document.createElement('a');
            const filename = `hand_landmarks_${Date.now()}.json`;
            link.download = filename;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);
            
            showNotification(`ğŸ“„ JSONæ•°æ®å·²å¯¼å‡º: ${filename}`);
        }

        // å¯¼å‡ºCSV
        function exportCSV() {
            if (!currentHandData || currentHandData.hands.length === 0) {
                showNotification('âš ï¸ å½“å‰æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹éƒ¨æ•°æ®');
                return;
            }
            
            // CSVå¤´éƒ¨
            let csvContent = 'Timestamp,Hand,Gesture,Confidence,LandmarkIndex,LandmarkName,LandmarkNameCN,X,Y,Z,ScreenX,ScreenY\n';
            
            // æ·»åŠ æ•°æ®è¡Œ
            currentHandData.hands.forEach(hand => {
                hand.landmarks.forEach(lm => {
                    csvContent += `${currentHandData.timestamp},`;
                    csvContent += `${hand.handedness},`;
                    csvContent += `${hand.gesture},`;
                    csvContent += `${hand.confidence.toFixed(4)},`;
                    csvContent += `${lm.index},`;
                    csvContent += `${lm.name},`;
                    csvContent += `${lm.nameCN},`;
                    csvContent += `${lm.x.toFixed(6)},`;
                    csvContent += `${lm.y.toFixed(6)},`;
                    csvContent += `${lm.z.toFixed(6)},`;
                    csvContent += `${lm.screenX.toFixed(2)},`;
                    csvContent += `${lm.screenY.toFixed(2)}\n`;
                });
            });
            
            // æ·»åŠ BOMä»¥æ”¯æŒä¸­æ–‡
            const BOM = '\uFEFF';
            const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8' });
            const link = document.createElement('a');
            const filename = `hand_landmarks_${Date.now()}.csv`;
            link.download = filename;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);
            
            showNotification(`ğŸ“Š CSVæ•°æ®å·²å¯¼å‡º: ${filename}`);
        }

        // æ˜¾ç¤ºé€šçŸ¥
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 2000);
        }

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (e.key === 'd' || e.key === 'D') {
                debugMode = !debugMode;
                document.getElementById('debug-info').style.display = 
                    debugMode ? 'block' : 'none';
            }
            if (e.key === 'r' || e.key === 'R') {
                // é‡æ–°å¼€å§‹
                clearHandElements();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                gestureCtx.clearRect(0, 0, gestureCanvas.width, gestureCanvas.height);
                gestureEffects = [];
                updateStatus('é‡æ–°æ£€æµ‹ä¸­...', '#ff0');
            }
            // å¿«æ·é”®
            if (e.key === 's' || e.key === 'S') {
                captureScreenshot();
            }
            if (e.key === 'j' || e.key === 'J') {
                exportJSON();
            }
            if (e.key === 'c' || e.key === 'C') {
                exportCSV();
            }
        });
    </script>
</body>
</html>